
class org.scn.community.utils.KeyText {
	String key;
	String text;
}

class org.scn.community.utils.DataRow {
	String key;
	org.scn.community.utils.KeyTextArray keys;
	String getDimensionValueKey( /**Dimension Key**/ String dimensionKey){* *}
	String getDimensionValueText( /**Dimension Key**/ String dimensionKey){* *}
	float getMeasureValue( /**Measure Key**/ String measureKey){* *}
	String getMeasureFormattedValue( /**Measure Key**/ String measureKey){* *}
}
class org.scn.community.utils.KeyTextArray extends Array {
	org.scn.community.utils.KeyTextArray (org.scn.community.utils.KeyText b);
	org.scn.community.utils.KeyText atIndex(int index) {* *}
}
class org.scn.community.utils.DataRowArray extends Array {
	org.scn.community.utils.DataRowArray (org.scn.community.utils.DataRow b);
	org.scn.community.utils.DataRow atIndex(int index) {* *}
	org.scn.community.utils.DataRowArray containing(Object options) {* *}
}
class org.scn.community.utils.DataIterator extends org.scn.community.shared.Component {

	/**
	 * Sets Ignore Totals
	 */	
	void setIgnoreTotals( /**Ignore Totals*/ boolean ignoreTotals){*
		this.ignoreTotals = ignoreTotals;
	*}

	/**
	 * Gets Ignore Totals
	 */	
	boolean getIgnoreTotals() {*
		return this.ignoreTotals;
	*}
	/**
	 * Determine if a value is not a number
	 */
	boolean isNaN(float value) {*
		this.internal_assureGlobalAccess();
		var global = this.getGlobal();
		return global.isNaN(value);
	*}
	/**
	 * Determine if a value is null
	 */
	boolean isNull(float value) {*
		return (value == null);
	*}
	/**
	 * Return a null
	 */
	float makeNull() {*
		return null;
	*}
	/**
	 * Get Key/Text of 'Measures' currently assigned in Rows
	 */
	org.scn.community.utils.KeyTextArray getMeasures(){*
		var flat = JSON.parse(this.flat);
		var ret = [];
		ret.atIndex = function(index){
			return this[index];
		}
		if(!flat.values){
			
		}else{
			for(var d = 0; d < flat.columnHeaders.length; d++){
				ret.push({
					key : flat.columnHeadersKeys[d],	// 0SALES
					text : flat.columnHeaders[d] 		// Sales
				});
			}			
		}
		return ret;
	*}
	/**
	 * Get Key/Text of 'Dimensions' currently assigned in Rows
	 */
	org.scn.community.utils.KeyTextArray getDimensions(){*
		var flat = JSON.parse(this.flat);
		var ret = [];
		ret.atIndex = function(index){
			return this[index];
		}
		if(!flat.values){
			
		}else{
			for(var d = 0; d < flat.dimensionHeadersKeys.length; d++){
				ret.push({
					key : flat.dimensionHeadersKeys[d],	// 0PRODUCT
					text : flat.dimensionHeaders[d] 	// Product
				});
			}			
		}
		return ret;
	*}
	/**
	 * Determine Dimension Column Index
	 */
	int determineDimension(Object filter) {*
		var flat = JSON.parse(this.flat);
		var index = -1;
		var key = null;
		if(filter.key){
			for(var d = 0; d < flat.dimensionHeadersKeys.length; d++){
				var fkey = flat.dimensionHeadersKeys[d];
				if(fkey == filter.key) {
					index = d;
					key = fkey;
				}
			}
		}
		if(filter.index){
			if(filter.index < flat.fimensionHeadersKeys.length) {
				index = filter.index;
				key = flat.dimensionHeadersKeys[index]; 
			}
		}
		return {
			index : index,
			key : key
		};
	*}
	/**
	 * Create Empty Data Row Array Object
	 */
	org.scn.community.utils.DataRowArray createDataRowArray() {*
		var that = this;
		var ret = [];
		ret.atIndex = function(index){
			return this[index];
		};
		ret.containing = function(options){
			var newRet = createDataRowArray();
			var passes = [];
			for(var i=0;i<this.length;i++) passes.push(false);
			if(options.dimensions){
				for(var d=0; d<options.dimensions.length; d++){
					var dim = that.determineDimension(options.dimensions[d]);
					if(dim.index>-1) {
						for(var r=0;r<this.length;r++){
							var row = this[r];
							var key = row.getDimensionValueKey(dim.key);
							//APPLICATION.log("Comparing " + key + " to " + options.dimensions[d].value);
							if(key == options.dimensions[d].value) passes[r] = true;
						}
					}
				}
			}
			for(var r=0;r<this.length;r++){
				if(passes[r]) newRet.push(this[r]);
			}
			if(options.measures){
				
			}
			//APPLICATION.log(JSON.stringify(newRet));
			return newRet;
		}
		return ret;
	*}
	/**
	 * Get Flattened (Rows) representation of the Assigned Data Source's current state.
	 */
	org.scn.community.utils.DataRowArray getRows (optional int offset, optional int maxRows) {*
		var flat = JSON.parse(this.flat);
		var ret = createDataRowArray();
		var rowOffset = 0;
		if(offset) rowOffset = offset;
		var max = -1;
		if(maxRows) max = maxRows;
		if(!flat.values){
			// No Data Source
		}else{
			var count = 0;
			for(var i=rowOffset;i<flat.values.length;i++){
				count++;
				if(max > -1 && count > max) break;
				var newRow = {
					key : "",
					keys : [],
					measures : {},
					dimensions : {},
					getDimensionValueKey : function(key){ return this.dimensions[key].key; },
					getDimensionValueText : function(key){ return this.dimensions[key].text; },
					getMeasureValue : function(key){ return this.measures[key].value; },
					getMeasureFormattedValue : function(key){ return this.measures[key].formattedValue; }
				};
				
				// Assign Dimension Member Values
				var members = [];
				for(var d = 0; d < flat.dimensionHeadersKeys.length; d++){
					var dimension = flat.dimensionHeadersKeys[d];	// 0PRODUCT
					var member = {
						key : flat.rowHeadersKeys2D[i][d],
						text : flat.rowHeaders2D[i][d]
					};
					members.push(member);
					newRow.dimensions[dimension] = member;
				}			
				// Assign Measure Values
				for(var m = 0; m< flat.columnHeadersKeys.length; m++){
					var measure = flat.columnHeadersKeys[m];	// 0BALANCE
					var value = {
						value : flat.values[i][m],
						formattedValue : flat.formattedValues[i][m]
					}
					newRow.measures[measure] = value;
				}
				var key = "";
				members.map(function(member){
					key += member.key;
				});
				newRow.key = key;
				newRow.keys = members;
				ret.push(newRow);
			}
		}
		return ret;
	*}
}
