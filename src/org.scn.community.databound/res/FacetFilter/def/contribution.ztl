/**
 * Class for DataDropDown
 */
class org.scn.community.databound.FacetFilter extends org.scn.community.shared.DataComponent {

	
	/**
	 * Returns the value of max members property
	 */
	int getMaxMembers() {*
		return this.DMaxMembers;
	*}

	/**
	 * Sets the value of max members property
	 */
	void setMaxMembers(int value) {*
		this.DMaxMembers = value;
	*}
	
	/**
	 * Returns the value of mark available
	 */
	boolean getMarkAvailable() {*
		return this.DMarkAvailable;
	*}

	/**
	 * Sets the value of mark available
	 */
	void setMarkAvailable(boolean value) {*
		this.DMarkAvailable = value;
	*}
	
	/**
	 * Returns the value of mark not available
	 */
	boolean getMarkNotAvailable() {*
		return this.DMarkNotAvailable;
	*}

	/**
	 * Sets the value of mark not available
	 */
	void setMarkNotAvailable(boolean value) {*
		this.DMarkNotAvailable = value;
	*}
	
	/**
	 * Returns the value of reset selection on not available
	 */
	boolean getResetSelectionOnNotAvailable() {*
		return this.DResetSelectionOnNotAvailable;
	*}

	/**
	 * Sets the value of reset selection on not available
	 */
	void setResetSelectionOnNotAvailable(boolean value) {*
		this.DResetSelectionOnNotAvailable = value;
	*}
	
	/**
	 * Returns the value of clear others
	 */
	boolean getClearOthers() {*
		return this.DClearOthers;
	*}

	/**
	 * Sets the value of clear others
	 */
	void setClearOthers(boolean value) {*
		this.DClearOthers = value;
	*}
	
	/**
	 * DO NOT USE PRIVATE METHODS
	 */
	void private_onSelectionChanged () {*
		var that = this;
		try{
		if(DEBUG) {	DEBUG.openZtl(this)};
		
		var l = {};
		l.selection = this.DSelection;
	
		l.selectionJson = JSON.parse(l.selection);
		
		l.dimensionName = l.selectionJson.dimension;
		l.keys = l.selectionJson.keys;
		
		l.keysAsArray = [];

		l.DS = this.getDataSource();
		
		if(DEBUG) {	DEBUG.inspectZtl(that, l)};
		
		if(l.DS) {
			if(l.selectionJson.clearOthers && that.getClearOthers()) {
				l.dimensions = undefined;
				
				if(this.DContentMode == "Only from Result Set") {
					l.dimensionsRows = DS.getDimensions(Axis.ROWS);
					l.dimensionsColumns = DS.getDimensions(Axis.COLUMNS);
					
					l.dimensions = [];

					l.dimensionsRows.forEach(function(dimension, indexD) {
						l.dimensions.push(dimension);
					});	
					l.dimensionsColumns.forEach(function(dimension, indexD) {
						l.dimensions.push(dimension);
					});
				} else {
					l.dimensions = DS.getDimensions();
				}
				
				if(DEBUG) {	DEBUG.inspectZtl(this, l)};
				
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						l.currentDimensionName = dimension.name
						if(l.currentDimensionName != l.dimensionName) {
							l.DS.clearFilter(l.currentDimensionName);
						}
					}
				});
			}
			
			if(l.keys.length == 1 && l.keys[0] == "-ALL-") {
				l.DS.clearFilter(l.dimensionName);
			} else {
				for (var iK = 0; iK < l.keys.length; iK++) {
					l.key = l.keys[iK];
					
					l.keysAsArray.push(l.key);
				}
				
				if(DEBUG) {	DEBUG.inspectZtl(that, l)};
				
				l.DS.setFilter(l.dimensionName, l.keysAsArray);
			}
		}
		
		if(DEBUG) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(DEBUG) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
	*}

	/**
	 * DO NOT USE PRIVATE METHODS
	 */
	void private_onBeforeRender() {*
	*}
	
	/**
	 * This function must be used for initialization and in case the drilldown structure has been changed.
	 * You should trigger it once and ideally when filters are NOT set on dimensions, other case you will see only members which are available in resultset (depends on your setting "member selection" on dimension level).
	 * When to use this method?
	 * - As soon the Data Source is initialized, either in "onStartup()" script or after loading in script.
	 * <example>
	 * You have loaded the data source and want to initialize.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACETFILTER_1.reloadDataSource();
	 * FACETFILTER_1.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACETFILTER_1.reloadDataSource(DS_FULL);
	 * FACETFILTER_1.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadDataSource(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
	
		try{
		if(DEBUG) {	DEBUG.openZtl(that)};
		var l = {};
		/* entering general block*/
		
		l.elementsJson = [];

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}

		if(l.DS) {
			l.dimensions = undefined;
			
			if(this.DContentMode == "Only from Result Set") {
				l.dimensionsRows = DS.getDimensions(Axis.ROWS);
				l.dimensionsColumns = DS.getDimensions(Axis.COLUMNS);
				
				l.dimensions = [];

				l.dimensionsRows.forEach(function(dimension, indexD) {
					l.dimensions.push(dimension);
				});	
				l.dimensionsColumns.forEach(function(dimension, indexD) {
					l.dimensions.push(dimension);
				});
			} else {
				l.dimensions = DS.getDimensions();
			}
			
			if(DEBUG) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensionKeys = "";
			l.dimensions.forEach(function(dimension, index) {
				l.dimensionKeys = l.dimensionKeys + dimension.name;
			});
			
			if(this.oldDimensionKeys != l.dimensionKeys) {
				l.dimensions.forEach(function(dimension, index) {
					l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());
		
					l.dimensionJson = {};
					l.dimensionJson.name = dimension.name;
					l.dimensionJson.text = dimension.text;
					l.dimensionJson.isMeasuresDimension = dimension.isMeasuresDimension;
		
					l.dimensionJson.hierarchyActive = DS.isHierarchyActive(dimension);
					l.dimensionJson.filterExt = ";" + DS.getFilterExt(dimension);
					
					l.dimensionJson.members = l.members;
		
					l.elementsJson.push(l.dimensionJson);
				});

				this.DElements = JSON.stringify(l.elementsJson);
				this.oldDimensionKeys = l.dimensionKeys;
				
				if(DEBUG) {	DEBUG.inspectZtl(that, l)};
			}
		}
		
		/* exiting general block*/
		if(DEBUG) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(DEBUG) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}
	
	/**
	 * This function can be used after the filter in data source was changed to update the component.
	 * You should be trigered every time the filter change occurs, therefore the event in Data Source -> onResultSetChanged() is a good place.
	 * When to use this method?
	 * - Always the filter is changed, also the "onResultSetChanged()" event is good for this.
	 * <example>
	 * You want to keep the selections with data source.
	 * The code should be placed in "onResultSetChanged()" method.
	 * <code>
	 * // if you want to update also dimensions when drilldown is changed
	 * FACETFILTER_1.reloadDataSource();
	 * 
	 * // every time 
	 * FACETFILTER_1.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACETFILTER_1.reloadDataSource(DS_FULL);
	 * FACETFILTER_1.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadSelection(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
	
		try{
		if(DEBUG) {	DEBUG.openZtl(that)};
		var l = {};
		/* entering general block*/
	
		l.elementsJson = {};

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}
		
		if(l.DS) {
			l.dimensions = undefined;
			
			if(DEBUG) {	DEBUG.inspectZtl(that)};
			
			if(this.DContentMode == "Only from Result Set") {
				l.dimensionsRows = l.DS.getDimensions(Axis.ROWS);
				l.dimensionsColumns = l.DS.getDimensions(Axis.COLUMNS);
				
				l.dimensions = [];
				
				l.dimensionsRows.forEach(function(dimension, indexD) {
					l.dimensions.push(dimension);
				});
				l.dimensionsColumns.forEach(function(dimension, indexD) {
					l.dimensions.push(dimension);
				});
			} else {
				l.dimensions = DS.getDimensions();
			}
			
			if(DEBUG) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensions.forEach(function(dimension, indexD) {
				l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());

				l.dimensionJson = {};
				l.dimensionJson.name = dimension.name;
				l.dimensionJson.members = [];
				l.dimensionJson.filterExt = "; " + l.DS.getFilterExt(dimension) + ";";

				l.elementsJson[dimension.name] = l.dimensionJson;
			});

			this.DSelection = JSON.stringify(l.elementsJson);
			
			if(DEBUG) {	DEBUG.inspectZtl(that, l)};
		}
		
		/* exiting general block*/
		if(DEBUG) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(DEBUG) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}
	
	/**
	 * Sets the sorting direction - ASCENDING | DESCENDING
	 */
	void setSortingDirection (org_scn_community_shared_SortDirectionEnumfield direction) {*
		if(direction == org_scn_community_shared_SortDirection.ASCENDING) {
			this.DSortingType = "Ascending";
			return;
		}
		if(direction == org_scn_community_shared_SortDirection.DESCENDING) {
			this.DSortingType = "Descending";
			return;
		}
		this.DSortingType = "Ascending";
	*}
	
	/**
	 * Sets the sorting type - DEFAULT | ALPHABETICAL | SELECTED | AVAILABLE
	 */
	void setSortingType (org_scn_community_shared_SortTypeEnumfield type) {*
		if(type == org_scn_community_shared_SortType.DEAFULT) {
			this.DSortingType = "Default";
			return;
		}
		if(type == org_scn_community_shared_SortType.ALPHABETICAL) {
			this.DSortingType = "Alphabetical";
			return;
		}
		if(type == org_scn_community_shared_SortType.SELECTED) {
			this.DSortingType = "Selected";
			return;
		}
		if(type == org_scn_community_shared_SortType.AVAILABLE) {
			this.DSortingType = "Available";
			return;
		}
		this.DSortingType = "Default";
	*}
}