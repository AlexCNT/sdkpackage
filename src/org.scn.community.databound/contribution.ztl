/* GENERATED - DO NOT EDIT */
/**
 * Copyright 2014, Contributors
 * 
 * Original Source Code Location:
 *  https://github.com/org-scn-design-studio-community/sdkpackage/
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */


/**
 * Class for BulletChart
 */
class org.scn.community.databound.BulletChart extends org.scn.community.shared.Component {
	/* get the unique key for the clicked bullet chart */
    String getClickedGraphKey() {*  
    	return this.clickedgraphkey;
    *}

}
class org.scn.community.databound.Choropleth extends org.scn.community.shared.Component {
	/**
	Get selected feature
	*/
	String getSelectedFeature() {*
		return this.selectedFeature;
	*}
	/**
	Set Measure to use for coloring
	*/
	void setMeasure(/*Measure*/String measure) {*
		return this.measureMember = measure;
	*}
	/**
	Set Bubble Measure to use for coloring
	*/
	void setBubbleMeasure(/*Measure*/String measure) {*
		return this.bubbleMember = measure;
	*}
	/**
	Set Projection Method
	*/
	void setProjection(/*Projection*/String projection) {*
		this.projection = projection;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		return this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
	/**
	Set Bubble Color
	*/
	void setBubbleColor(/*Color*/String color) {*
		this.bubbleColor = color;
	*}
	/**
	Set Feature Attribute from GeoJSON that matches values in rows
	*/
	void setFeatureProperty(/*Attribute*/String attribute) {*
		this.featureProperty = attribute;
	*}
	/**
	Set Label Attribute from GeoJSON that should be used for labeling
	*/
	void setLabelProperty(/*Attribute*/String attribute) {*
		this.labelProperty = attribute;
	*}
}
class org.scn.community.databound.Table extends org.scn.community.shared.DataComponent {

	/* Sets the data displayed in the first column. */
	void setColumn1Selection(/* A selection specifying a single column (or row) of keyfigures from a data source */ ResultCellListSelection selection) {*
		this.column1 = this.stringifySelection(selection);
	*}

	/* Sets the data displayed in the second column. */
	void setColumn2Selection(/* A selection specifying a single column (or row) of keyfigures from a data source */ ResultCellListSelection selection) {*
		this.column2 = this.stringifySelection(selection);
	*}

	/* Sets the data displayed in the third column. */
	void setColumn3Selection(/* A selection specifying a single column (or row) of keyfigures from a data source */ ResultCellListSelection selection) {*
		this.column3 = this.stringifySelection(selection);
	*}
}

/**
 * Class for DataDropDown
 */
class org.scn.community.databound.DropDown extends org.scn.community.shared.DataComponent {

	void private_onSelectionChanged () {*
		var key = this.getSelectedKey();
	
		this.internalWriteLog("Internal Selection on Dimension: " + this.getDimension() + " | " + key);

		if(key == "-CLEAR-") {
			this.getDataSource().clearFilter(this.getDimension());
		} else {
			this.getDataSource().setFilter(this.getDimension(), key);	
		}
	*}
	
	void private_onBeforeRender() {*
		
	*}
	
	void reloadDataSource() {*
		// unfortunately this does not work correctly as this method is too late included (as first method on rendering, instead on before rendering)
		// this causes incorrect events in a phase where events are not allowed any more... (error: DS_1 cannot be changed in rendering phase)
		// workaround is to call once explicitelly "getMembers" on this dimension
		if(this.DBindingMode == "Master Data") {
			this.internalWriteLog("Call Members on Dimension: " + this.getDimension() + " | " + this.DMaxMembers);
			this.DElements = this.superReadMembers(this.getDimension(), this.DMaxMembers);	
		}
	
		// check current selection from data source
		var selectionExt = this.getDataSource().getFilterExt(this.getDimension());
		this.internalWriteLog("Selection on Dimension: " + this.getDimension() + " | " + selectionExt);

		this.DSelectedKeyExtFull = selectionExt;
		
		// only single member
		if(selectionExt.indexOf(";") == -1 && selectionExt.indexOf(" - ") == -1) {
			this.DSelectedKeyExt = selectionExt;	
		} else {
			this.DSelectedKeyExt = "";
		}
	*}

	/** returns the selected key 
    <example>
	You want to get first and second selected key in the range
	<code>
    var selection1 = DATARANGESLIDER_1.getSelectedKey();
	var selection2 = DATARANGESLIDER_1.getSelectedKey2();
	
	APPLICATION.createInfoMessage("Selected Range: " + selection1 + " - " + selection2);
	APPLICATION.createInfoMessage("Selected Range Keys: " + DATARANGESLIDER_1.getSelectedKeys());
	
	if(selection1.indexOf("-N/A-") > -1 || selection2.indexOf("-N/A-") > -1) {
		// do nothing
	} else {
		DS_1.setFilterExt("0BC_PERS1", "" + DATARANGESLIDER_1.getSelectedKey()  + " - " + DATARANGESLIDER_1.getSelectedKey2());
	}
	</code>
	</example>
	*/
	String getSelectedKey () {*
		return this.DSelectedKey;	
	*}

	/** returns the selected text */
	String getSelectedText () {*
		return this.DSelectedText;	
	*}
	
	/** gest the dimension */
	String getDimension () {*
		return this.DDimension;	
	*}
	
	/** sets the dimension */
	void setDimension (String dimension) {*
		this.DDimension = dimension;	
	*}
	
	/** sets the pause refresh flag */
	void pauseRefresh () {*
		this.DDoRefresh = false;	
	*}

	/** sets the pause refresh flag */
	void allowRefresh () {*
		this.DDoRefresh = true;	
	*}
}

/**
 * Class for D3Hier
 */
class org.scn.community.databound.jpd3hier extends org.scn.community.shared.DataComponent {

	/* Returns the Key of the currently selected Tree Element. */
	String getSelectedNodeKey() {*
		return this.selectedNode;
	*}
	
	/* Returns the Dimension Key containing the hierarchy of the datasource. */
	String getHierarchyDimensionKey() {*
		return this.dimHierarchy;
	*}
	
	/* Returns the maximum Size of the Bubbles in Pixel */
	String getBubbleSizeMaxSize() {*
		return this.BubbleSizeMaxSize;
	*}
	
	/* Sets the maximum Size of the Bubbles in Pixel */
	void setBubbleSizeMaxSize(/* New maximum Bubble size in Pixel */ int newBubbleSize) {*
		this.BubbleSizeMaxSize = newBubbleSize;
	*}
	
	/* Sets the Bubble Size Keyfigure id during runtime */
	void setkfBubbleSize(/* New id of a keyfigure column */ String newkfBubbleSizeId) {*
		this.kfBubbleSize = newkfBubbleSizeId;
	*}
	
	/* Gets the Bubble Size Keyfigure id during runtime */
	void getkfBubbleSize() {*
		return this.kfBubbleSize;
	*}
	
	/* Sets the Bubble Alerter Keyfigure id during runtime */
	void setkfBubbleAlerter(/* New id of a keyfigure column */ String newkfBubbleAlerterId) {*
		this.kfColBub = newkfBubbleAlerterId;
	*}
	
	/* Gets the Bubble Alerter Keyfigure id during runtime */
	void getkfBubbleAlerter() {*
		return this.kfColBub;
	*}
	
	/* Sets the Bubble Alerter Color Value for Green during runtime */
	void setAlerterColorGreenVal(/* New value for the Bubble color Green*/ int newAlerterColorGreenVal) {*
		this.AlerterColorGreenVal = newAlerterColorGreenVal;
	*}
	
	/* Sets the Bubble Alerter Color Value for Yellow during runtime */
	void setAlerterColorYellowVal(/* New value for the Bubble color Yellow*/ int newAlerterColorYellowVal) {*
		this.AlerterColorYellowVal = newAlerterColorYellowVal;
	*}
	
	/* Returns the x-translation of the whole tree in Pixel */
	String getBubbleRootXTranslation() {*
		return this.BubbleRootXTranslation;
	*}
	/* Sets the x-translation of the whole tree in Pixel */
	void setBubbleRootXTranslation(/* New x translation in Pixel -> positive = right, negative = left*/ int newXTranslation) {*
		this.BubbleRootXTranslation = newXTranslation;
	*}
	
	/* Expand the hierarchy (used for DS 1.4 private functionality) - it seems that the private call does not work */
	@Visibility(private) 
	void expandHierarchyNode() {*
	    this.getDataSource().expandNode(this.getHierarchyDimensionKey(), this.getSelectedNodeKey());
	*}
	
	/* Collapse the hierarchy (used for DS 1.4 private functionality) - it seems that the private call does not work */
	@Visibility(private) 
	void collapseHierarchyNode() {*
		this.getDataSource().collapseNode(this.getHierarchyDimensionKey(), this.getSelectedNodeKey());
	*}
	
	/* Expand the hierarchy */
	void expandHierarchyNodes() {*
	    this.getDataSource().expandNode(this.getHierarchyDimensionKey(), this.getSelectedNodeKey());
	*}
	
	/* Collapse the hierarchy */
	void collapseHierarchyNodes() {*
		this.getDataSource().collapseNode(this.getHierarchyDimensionKey(), this.getSelectedNodeKey());
	*}
	
}

/**
 * Generated ZTL Class for FacetFilter
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.FacetFilter extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Clear Selections if 0 Property
	 */	
	void setClearOthers( /**Clear Selections if 0*/ boolean clearOthers){*
		this.DClearOthers = clearOthers;
	*}

	/**
	 * Gets Clear Selections if 0 Property
	 */	
	boolean isClearOthers() {*
		return this.DClearOthers;
	*}

	/**
	 * Sets Content Mode Property by String
	 */	
	void setContentModeByString( /**Content Mode*/ String contentMode){*
		this.DContentMode = contentMode;
	*}

	/**
	 * Gets Content Mode Property as String
	 */	
	String getContentModeAsString() {*
		return this.DContentMode;
	*}

	/**
	 * Sets Custom Dimensions Property as StringArray
	 */	
	void setCustomDimensions( /**Custom Dimensions*/ StringArray customDimensions){*
		this.DCustomDimensions = customDimensions;
	*}
	
	/** Gets Custom Dimensions Property as StringArray

 	<example>
	You want to ask for the current property value
	<code>
	FACETFILTER.getCustomDimensions();<br>
	</code>
	</example>
	 */
	StringArray getCustomDimensions () {*		
		var elementsJson = JSON.parse(this.DCustomDimensions);
		return elementsJson;
	*}

	/**
	 * Sets Display Text Property by String
	 */	
	void setDisplayTextByString( /**Display Text*/ String displayText){*
		this.DDisplayText = displayText;
	*}

	/**
	 * Gets Display Text Property as String
	 */	
	String getDisplayTextAsString() {*
		return this.DDisplayText;
	*}



	/**
	 * Sets Facet Width in px Property
	 */	
	void setFacetWidth( /**Facet Width in px*/ int facetWidth){*
		this.DFacetWidth = facetWidth;
	*}

	/**
	 * Gets Facet Width in px Property
	 */	
	int getFacetWidth() {*
		return this.DFacetWidth;
	*}

	/**
	 * Sets Maximum Number of Members Property
	 */	
	void setMaxDisplayMembers( /**Maximum Number of Members*/ int maxDisplayMembers){*
		this.DMaxDisplayMembers = maxDisplayMembers;
	*}

	/**
	 * Gets Maximum Number of Members Property
	 */	
	int getMaxDisplayMembers() {*
		return this.DMaxDisplayMembers;
	*}

	/**
	 * Sets Maximum Number of Members Property
	 */	
	void setMaxMembers( /**Maximum Number of Members*/ int maxMembers){*
		this.DMaxMembers = maxMembers;
	*}

	/**
	 * Gets Maximum Number of Members Property
	 */	
	int getMaxMembers() {*
		return this.DMaxMembers;
	*}

	/**
	 * Sets Second Value Content Property by String
	 */	
	void setSecondValueContentByString( /**Second Value Content*/ String secondValueContent){*
		this.DSecondValueContent = secondValueContent;
	*}

	/**
	 * Gets Second Value Content Property as String
	 */	
	String getSecondValueContentAsString() {*
		return this.DSecondValueContent;
	*}



	/**
	 * Sets Show Second Value Property
	 */	
	void setShowSecondValue( /**Show Second Value*/ boolean showSecondValue){*
		this.DShowSecondValue = showSecondValue;
	*}

	/**
	 * Gets Show Second Value Property
	 */	
	boolean isShowSecondValue() {*
		return this.DShowSecondValue;
	*}

	/**
	 * Sets Member Sorting Direction Property by String
	 */	
	void setSortingDirectionByString( /**Member Sorting Direction*/ String sortingDirection){*
		this.DSortingDirection = sortingDirection;
	*}

	/**
	 * Gets Member Sorting Direction Property as String
	 */	
	String getSortingDirectionAsString() {*
		return this.DSortingDirection;
	*}

	/**
	 * Sets Member Sorting Type Property by String
	 */	
	void setSortingTypeByString( /**Member Sorting Type*/ String sortingType){*
		this.DSortingType = sortingType;
	*}

	/**
	 * Gets Member Sorting Type Property as String
	 */	
	String getSortingTypeAsString() {*
		return this.DSortingType;
	*}

	/**
	 * Sets Zero Values Display Mode Property by String
	 */	
	void setZeroValuesModeByString( /**Zero Values Display Mode*/ String zeroValuesMode){*
		this.DZeroValuesMode = zeroValuesMode;
	*}

	/**
	 * Gets Zero Values Display Mode Property as String
	 */	
	String getZeroValuesModeAsString() {*
		return this.DZeroValuesMode;
	*}








	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */
	/**
	 * Reads the Dimensions from Data Source 
	 */
	@Visibility(private)
	void private_readDimensions (Object dataSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		if(this.DContentMode == "Only from Result Set") {
			l.dimensionsRows = dataSource.getDimensions(Axis.ROWS);
			l.dimensionsColumns = dataSource.getDimensions(Axis.COLUMNS);
			
			l.dimensions = [];

			l.dimensionsRows.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});	
			l.dimensionsColumns.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		} else if(this.DContentMode == "Custom Dimension Set") {
			l.dimensionsAll = dataSource.getDimensions();
			l.customDimensions = JSON.parse(that.DCustomDimensions);
			
			l.customDimensionsFlat = "|";
			for (var iD = 0; iD < l.customDimensions.length; iD++) {
				l.customDimensionsFlat = l.customDimensionsFlat + l.customDimensions[iD] + "|";
			}
			
			l.dimensions = [];
			
			l.dimensionsAll.forEach(function(dimension, indexD) {
				l.currentAvailableDimensionName = dimension.name; 
				if(l.customDimensionsFlat.indexOf("|" + l.currentAvailableDimensionName + "|") > -1) {
					l.dimensions.push(dimension);
				}
			});	
		} else {
			l.dimensions = dataSource.getDimensions();
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
		
		this._tempDimensions = l.dimensions;
	*}

	/**
	 * Resets the actual data of all dimensions (and causes reload of all members in "reloadDataSource" method.
	 * Use it together like below
	 * <example>
	 * You want to reload actual members again
	 * <code>
	 * FACET.resetDimensions();
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 */
	void resetDimensions() {*
		this.oldDimensionKeys = "";
	*}

	/**
	 * This function must be used for initialization and in case the drilldown structure has been changed.
	 * You should trigger it once and ideally when filters are NOT set on dimensions, other case you will see only members which are available in resultset (depends on your setting "member selection" on dimension level).
	 * When to use this method?
	 * - As soon the Data Source is initialized, either in "onStartup()" script or after loading in script.
	 * <example>
	 * You have loaded the data source and want to initialize.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource();
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource(DS_FULL);
	 * FACET.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadDataSource(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.elementsJson = [];

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}

		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensionKeys = "";
			l.dimensions.forEach(function(dimension, index) {
				l.dimensionKeys = l.dimensionKeys + dimension.name;
			});
			
			if(this.oldDimensionKeys != l.dimensionKeys) {
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						// warnings to assure query is ok
						if(l.DS.isHierarchyActive(dimension)) {
							APPLICATION.createWarningMessage("Data Source has an Active Hierarchy on Dimension: " + dimension.name);
						}
	
						l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());
	
						l.dimensionJson = {};
						l.dimensionJson.name = dimension.name;
						l.dimensionJson.text = dimension.text;
						l.dimensionJson.isMeasuresDimension = dimension.isMeasuresDimension;
	
						l.dimensionJson.hierarchyActive = l.DS.isHierarchyActive(dimension);
						l.dimensionJson.filterExt = ";" + l.DS.getFilterExt(dimension);
						
						l.dimensionJson.members = l.members;
			
						l.elementsJson.push(l.dimensionJson);
					}
				});

				this.DElements = JSON.stringify(l.elementsJson);
				this.oldDimensionKeys = l.dimensionKeys;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			}
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}

	/**
	 * This function can be used after the filter in data source was changed to update the component.
	 * You should be trigered every time the filter change occurs, therefore the event in Data Source -> onResultSetChanged() is a good place.
	 * When to use this method?
	 * - Always the filter is changed, also the "onResultSetChanged()" event is good for this.
	 * <example>
	 * You want to keep the selections with data source.
	 * The code should be placed in "onResultSetChanged()" method.
	 * <code>
	 * // if you want to update also dimensions when drilldown is changed
	 * FACET.reloadDataSource();
	 * 
	 * // every time 
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource(DS_FULL);
	 * FACET.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadSelection(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/
	
		l.elementsJson = {};

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}
		
		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensions.forEach(function(dimension, indexD) {
				l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());

				l.dimensionJson = {};
				l.dimensionJson.name = dimension.name;
				l.dimensionJson.members = [];
				l.dimensionJson.filterExt = "; " + l.DS.getFilterExt(dimension) + ";";

				l.elementsJson[dimension.name] = l.dimensionJson;
			});

			this.DSelection = JSON.stringify(l.elementsJson);
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		}
		
		/* exiting general block*/
		if(this.isDebug("DEBUG_2")) { DEBUG_2.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}
	
	/**
	 * DO NOT USE PRIVATE METHODS
	 */
	@Visibility(private)
	void private_onSelectionChanged () {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.selection = this.DSelection;
	
		l.selectionJson = JSON.parse(l.selection);
		
		l.dimensionName = l.selectionJson.dimension;
		l.keys = l.selectionJson.keys;
		
		l.keysAsArray = [];

		l.DS = this.getDataSource();
		
		if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		
		if(l.DS) {
			if(l.selectionJson.clearOthers && that.isClearOthers()) {
				this.private_readDimensions(l.DS);
				l.dimensions = this._tempDimensions;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(this, l)};
				
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						l.currentDimensionName = dimension.name
						if(l.currentDimensionName != l.dimensionName) {
							l.DS.clearFilter(l.currentDimensionName);
						}
					}
				});
			}
			
			if(l.keys.length == 1 && l.keys[0] == "-ALL-") {
				l.DS.clearFilter(l.dimensionName);
			} else {
				for (var iK = 0; iK < l.keys.length; iK++) {
					l.key = l.keys[iK];
					
					l.keysAsArray.push(l.key);
				}
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
				
				l.DS.setFilter(l.dimensionName, l.keysAsArray);
			}
		}
		
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
	*}

}

/**
 * Generated ZTL Class for FacetSelector
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.FacetSelector extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Clear Selections if 0 Property
	 */	
	void setClearOthers( /**Clear Selections if 0*/ boolean clearOthers){*
		this.DClearOthers = clearOthers;
	*}

	/**
	 * Gets Clear Selections if 0 Property
	 */	
	boolean isClearOthers() {*
		return this.DClearOthers;
	*}

	/**
	 * Sets Content Mode Property by String
	 */	
	void setContentModeByString( /**Content Mode*/ String contentMode){*
		this.DContentMode = contentMode;
	*}

	/**
	 * Gets Content Mode Property as String
	 */	
	String getContentModeAsString() {*
		return this.DContentMode;
	*}

	/**
	 * Sets Custom Dimensions Property as StringArray
	 */	
	void setCustomDimensions( /**Custom Dimensions*/ StringArray customDimensions){*
		this.DCustomDimensions = customDimensions;
	*}
	
	/** Gets Custom Dimensions Property as StringArray

 	<example>
	You want to ask for the current property value
	<code>
	FACETSELECTOR.getCustomDimensions();<br>
	</code>
	</example>
	 */
	StringArray getCustomDimensions () {*		
		var elementsJson = JSON.parse(this.DCustomDimensions);
		return elementsJson;
	*}

	/**
	 * Sets Display Text Property by String
	 */	
	void setDisplayTextByString( /**Display Text*/ String displayText){*
		this.DDisplayText = displayText;
	*}

	/**
	 * Gets Display Text Property as String
	 */	
	String getDisplayTextAsString() {*
		return this.DDisplayText;
	*}



	/**
	 * Sets Facet Width in px Property
	 */	
	void setFacetWidth( /**Facet Width in px*/ int facetWidth){*
		this.DFacetWidth = facetWidth;
	*}

	/**
	 * Gets Facet Width in px Property
	 */	
	int getFacetWidth() {*
		return this.DFacetWidth;
	*}

	/**
	 * Sets Maximum Number of Members Property
	 */	
	void setMaxDisplayMembers( /**Maximum Number of Members*/ int maxDisplayMembers){*
		this.DMaxDisplayMembers = maxDisplayMembers;
	*}

	/**
	 * Gets Maximum Number of Members Property
	 */	
	int getMaxDisplayMembers() {*
		return this.DMaxDisplayMembers;
	*}

	/**
	 * Sets Maximum Number of Members Property
	 */	
	void setMaxMembers( /**Maximum Number of Members*/ int maxMembers){*
		this.DMaxMembers = maxMembers;
	*}

	/**
	 * Gets Maximum Number of Members Property
	 */	
	int getMaxMembers() {*
		return this.DMaxMembers;
	*}



	/**
	 * Sets Member Sorting Direction Property by String
	 */	
	void setSortingDirectionByString( /**Member Sorting Direction*/ String sortingDirection){*
		this.DSortingDirection = sortingDirection;
	*}

	/**
	 * Gets Member Sorting Direction Property as String
	 */	
	String getSortingDirectionAsString() {*
		return this.DSortingDirection;
	*}

	/**
	 * Sets Member Sorting Type Property by String
	 */	
	void setSortingTypeByString( /**Member Sorting Type*/ String sortingType){*
		this.DSortingType = sortingType;
	*}

	/**
	 * Gets Member Sorting Type Property as String
	 */	
	String getSortingTypeAsString() {*
		return this.DSortingType;
	*}

	/**
	 * Sets Zero Values Display Mode Property by String
	 */	
	void setZeroValuesModeByString( /**Zero Values Display Mode*/ String zeroValuesMode){*
		this.DZeroValuesMode = zeroValuesMode;
	*}

	/**
	 * Gets Zero Values Display Mode Property as String
	 */	
	String getZeroValuesModeAsString() {*
		return this.DZeroValuesMode;
	*}








	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */
	/**
	 * Reads the Dimensions from Data Source 
	 */
	@Visibility(private)
	void private_readDimensions (Object dataSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		if(this.DContentMode == "Only from Result Set") {
			l.dimensionsRows = dataSource.getDimensions(Axis.ROWS);
			l.dimensionsColumns = dataSource.getDimensions(Axis.COLUMNS);
			
			l.dimensions = [];

			l.dimensionsRows.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});	
			l.dimensionsColumns.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		} else if(this.DContentMode == "Custom Dimension Set") {
			l.dimensionsAll = dataSource.getDimensions();
			l.customDimensions = JSON.parse(that.DCustomDimensions);
			
			l.customDimensionsFlat = "|";
			for (var iD = 0; iD < l.customDimensions.length; iD++) {
				l.customDimensionsFlat = l.customDimensionsFlat + l.customDimensions[iD] + "|";
			}
			
			l.dimensions = [];
			
			l.dimensionsAll.forEach(function(dimension, indexD) {
				l.currentAvailableDimensionName = dimension.name; 
				if(l.customDimensionsFlat.indexOf("|" + l.currentAvailableDimensionName + "|") > -1) {
					l.dimensions.push(dimension);
				}
			});	
		} else {
			l.dimensions = dataSource.getDimensions();
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
		
		this._tempDimensions = l.dimensions;
	*}

	/**
	 * Resets the actual data of all dimensions (and causes reload of all members in "reloadDataSource" method.
	 * Use it together like below
	 * <example>
	 * You want to reload actual members again
	 * <code>
	 * FACET.resetDimensions();
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 */
	void resetDimensions() {*
		this.oldDimensionKeys = "";
	*}

	/**
	 * This function must be used for initialization and in case the drilldown structure has been changed.
	 * You should trigger it once and ideally when filters are NOT set on dimensions, other case you will see only members which are available in resultset (depends on your setting "member selection" on dimension level).
	 * When to use this method?
	 * - As soon the Data Source is initialized, either in "onStartup()" script or after loading in script.
	 * <example>
	 * You have loaded the data source and want to initialize.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource();
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource(DS_FULL);
	 * FACET.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadDataSource(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.elementsJson = [];

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}

		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensionKeys = "";
			l.dimensions.forEach(function(dimension, index) {
				l.dimensionKeys = l.dimensionKeys + dimension.name;
			});
			
			if(this.oldDimensionKeys != l.dimensionKeys) {
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						// warnings to assure query is ok
						if(l.DS.isHierarchyActive(dimension)) {
							APPLICATION.createWarningMessage("Data Source has an Active Hierarchy on Dimension: " + dimension.name);
						}
	
						l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());
	
						l.dimensionJson = {};
						l.dimensionJson.name = dimension.name;
						l.dimensionJson.text = dimension.text;
						l.dimensionJson.isMeasuresDimension = dimension.isMeasuresDimension;
	
						l.dimensionJson.hierarchyActive = l.DS.isHierarchyActive(dimension);
						l.dimensionJson.filterExt = ";" + l.DS.getFilterExt(dimension);
						
						l.dimensionJson.members = l.members;
			
						l.elementsJson.push(l.dimensionJson);
					}
				});

				this.DElements = JSON.stringify(l.elementsJson);
				this.oldDimensionKeys = l.dimensionKeys;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			}
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}

	/**
	 * This function can be used after the filter in data source was changed to update the component.
	 * You should be trigered every time the filter change occurs, therefore the event in Data Source -> onResultSetChanged() is a good place.
	 * When to use this method?
	 * - Always the filter is changed, also the "onResultSetChanged()" event is good for this.
	 * <example>
	 * You want to keep the selections with data source.
	 * The code should be placed in "onResultSetChanged()" method.
	 * <code>
	 * // if you want to update also dimensions when drilldown is changed
	 * FACET.reloadDataSource();
	 * 
	 * // every time 
	 * FACET.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACET.reloadDataSource(DS_FULL);
	 * FACET.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadSelection(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/
	
		l.elementsJson = {};

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}
		
		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensions.forEach(function(dimension, indexD) {
				l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());

				l.dimensionJson = {};
				l.dimensionJson.name = dimension.name;
				l.dimensionJson.members = [];
				l.dimensionJson.filterExt = "; " + l.DS.getFilterExt(dimension) + ";";

				l.elementsJson[dimension.name] = l.dimensionJson;
			});

			this.DSelection = JSON.stringify(l.elementsJson);
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		}
		
		/* exiting general block*/
		if(this.isDebug("DEBUG_2")) { DEBUG_2.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}
	
	/**
	 * DO NOT USE PRIVATE METHODS
	 */
	@Visibility(private)
	void private_onSelectionChanged () {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.selection = this.DSelection;
	
		l.selectionJson = JSON.parse(l.selection);
		
		l.dimensionName = l.selectionJson.dimension;
		l.keys = l.selectionJson.keys;
		
		l.keysAsArray = [];

		l.DS = this.getDataSource();
		
		if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		
		if(l.DS) {
			if(l.selectionJson.clearOthers && that.isClearOthers()) {
				this.private_readDimensions(l.DS);
				l.dimensions = this._tempDimensions;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(this, l)};
				
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						l.currentDimensionName = dimension.name
						if(l.currentDimensionName != l.dimensionName) {
							l.DS.clearFilter(l.currentDimensionName);
						}
					}
				});
			}
			
			if(l.keys.length == 1 && l.keys[0] == "-ALL-") {
				l.DS.clearFilter(l.dimensionName);
			} else {
				for (var iK = 0; iK < l.keys.length; iK++) {
					l.key = l.keys[iK];
					
					l.keysAsArray.push(l.key);
				}
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
				
				l.DS.setFilter(l.dimensionName, l.keysAsArray);
			}
		}
		
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
	*}

}
/**
 * enum field definition
 */
class org_scn_community_shared_ThresholdMethod extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_ThresholdMethodTypes extends Enum {

	/** CHECKED */
	org_scn_community_shared_ThresholdMethod CHECKED;
       
	/** UNCHECKED */
	org_scn_community_shared_ThresholdMethod UNCHECKED;

	/** MIXED */
	org_scn_community_shared_ThresholdMethod MIXED;
}


class org.scn.community.databound.HexBin extends org.scn.community.shared.DataComponent {
	/**
	Set Threshold Method
	*/
	void setThresholdMethod(/*Method*/ String method) {*
		this.thresholdMethod = method;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
	/**
	Set Hexagon Radius
	*/
	void setRadius(/*Radius (px)*/int radius) {*
		this.radius = radius;
	*}
	/**
	Get Hexagon Radius
	*/
	int getRadius() {*
		return this.radius;
	*}
	/**
	Set Max Threshold
	*/
	void setThreshold(/*Threshold*/int threshold) {*
		this.threshold = threshold;
	*}
	/**
	Get Max Threshold
	*/
	int getThreshold() {*
		return this.threshold;
	*}
	/**
	Set Min Threshold (Tolerance)
	*/
	void setTolerance(/*Tolerance*/int tolerance) {*
		this.tolerance = tolerance;
	*}
	/**
	Get Min Threshold (Tolerance)
	*/
	int getTolerance() {*
		return this.tolerance;
	*}
	/**
	Set X-Axis Measure by text
	*/
	void setMeasureX(/*Measure*/String measure) {*
		this.measureX = measure;
	*}
	/**
	Get X-Axis Measure text
	*/
	String getMeasureX() {*
		return this.measureX;
	*}
	/**
	Set Y-Axis Measure by text
	*/
	void setMeasureY(/*Measure*/String measure) {*
		this.measureY = measure;
	*}
	/**
	Get Y-Axis Measure text
	*/
	String getMeasureY() {*
		return this.measureY;
	*}
	/**
	Set Y-Axis Min
	*/
	void setMinY(/*Minimume*/int min) {*
		this.minY = min;
	*}
	/**
	Get Y-Axis Min
	*/
	int getMinY() {*
		return this.minY;
	*}
	/**
	Set Y-Axis Max
	*/
	void setMaxY(/*Minimume*/int max) {*
		this.maxY = max;
	*}
	/**
	Get Y-Axis Max
	*/
	int getMaxY() {*
		return this.maxY;
	*}
	/**
	Set X-Axis Min
	*/
	void setMinX(/*Minimume*/int min) {*
		this.minX = min;
	*}
	/**
	Get X-Axis Min
	*/
	int getMinX() {*
		return this.minX;
	*}
	/**
	Set X-Axis Max
	*/
	void setMaxX(/*Minimume*/int max) {*
		this.maxX = max;
	*}
	/**
	Get X-Axis Max
	*/
	int getMaxX() {*
		return this.maxX;
	*}
}

/**
 * Class for DataLeaderBoard
 */
class org.scn.community.databound.LeaderBoard extends org.scn.community.shared.DataComponent {

	/** returns the selected key */
	String getSelectedKey () {*
		return this.selectedKey;	
	*}
	
	/** sets the selected key */
	void setSelectedKey (String key) {*
		this.selectedKey = key;	
	*}

	/** returns the pressed key */
	String getPressedKey () {*
		return this.pressedKey;	
	*}
}
class org.scn.community.databound.LocationIntel extends org.scn.community.shared.Component {
	/**
	Get selected feature
	*/
	String getSelectedMarker() {*
		return this.selectedMarker;
	*}
	/**
	Set Projection Method
	*/
	void setProjection(/*Projection*/String projection) {*
		this.projection = projection;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		return this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
	/**
	Set Marker Color
	*/
	void setMarkerColor(/*Color*/String color) {*
		this.markerColor = color;
	*}
	/**
	Set Marker Title Field
	*/
	void setMarkerTitle(/*Color*/String dimension) {*
		this.markerTitle = dimension;
	*}
	/**
	Set Marker Size Field
	*/
	void setMarkerSizeMeasure(/*Color*/String measure) {*
		this.markerSizeMeasure = measure;
	*}
	/**
	Set Label Attribute from GeoJSON that should be used for labeling
	*/
	void setLabelProperty(/*Attribute*/String attribute) {*
		this.labelProperty = attribute;
	*}
}
class org.scn.community.databound.MarimekkoChart extends org.scn.community.shared.DataComponent {
	/**
	Get selected row
	*/
	String getSelectedRow() {*
		return this.selectedRow;
	*}
	/**
	Get selected column
	*/
	String getSelectedColumn() {*
		return this.selectedColumn;
	*}
	/**
	Get selected value
	*/
	float getSelectedValue() {*
		return this.selectedValue;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		return this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
}
class org.scn.community.databound.MultiLevelDropDown extends Component {
	
	/** ------- Getter / Setter for addSingleRootNode ------ */
	boolean getAddSingleRootNode() {*
		return this.addSingleRootNode;
	*}

	void setAddSingleRootNode(Boolean value) {*
		this.addSingleRootNode = value;
	*}
	
	/** ------- Getter / Setter for singleRootName ------ */
	String getSingleRootNodeName() {*
		return this.singleRootNodeName;
	*}

	void setSingleRootNodeName(String newName) {*
		this.singleRootNodeName = newName;
	*}
	
	/** ------- Getter / Setter for selectedElemKey ------ */
	String getSelectedElemKey() {*
		return this.SelectedElemKey;
	*}

	void setSelectedElemKey(String selectedKey) {*
		this.SelectedElemKey = selectedKey;
	*}
	
	/** ------- Getter / Setter for selectedElemKey ------ */
	String getvalueDisplayType() {*
		return this.valueDisplayType;
	*}

	void setvalueDisplayType(String value) {*
		this.valueDisplayType = value;
	*}
	
	/** ------- Getter / Setter for selectedElemKey ------ */
	String getSelectedElemText() {*
		return this.SelectedElemText;
	*}

	void setSelectedElemText(String selectedText) {*
		this.SelectedElemText = selectedText;
	*}
	
	/** ------- Getter / Setter for resetButton ------ */
	String getResetButton() {*
		return this.resetButton;
	*}

	void setResetButton(String value) {*
		this.resetButton = value;
	*}

	/** ------- Getter / Setter for singleRootName ------ */
	String getDimension() {*
		return this.selChar;
	*}

	void setDimension(String value) {*
		this.selChar = value;
	*}
	
	/** ------- Getter / Setter for addWeight ------ */
	boolean getAddWeight() {*
		return this.addWeight;
	*}

	void setAddWeight(Boolean value) {*
		this.addWeight = value;
	*}
	
	/** ------- Getter / Setter for selWeight ------ */
	String getSelWeight() {*
		return this.selWeight;
	*}

	void setSelWeight(String value) {*
		this.selWeight = value;
	*}
	
	/** ------- Getter / Setter for colorClass ------ */
	String getColorClass() {*
		return this.colorClass;
	*}

	void setColorClass(String value) {*
		this.colorClass = value;
	*}
	
	
}

/**
 * Generated ZTL Class for Nice Chart
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.NiceChart extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Chart Type Property
	 */	
	void setChartType( /* Chart Type */  choice chartType){*
		this.DChartType = chartType;
	*}

	/**
	 * Gets Chart Type Property
	 */	
	choice getChartType() {*
		return this.DChartType;
	*}

	/**
	 * Sets Starting Color Distance Property
	 */	
	void setColorDistance( /* Starting Color Distance */  float colorDistance){*
		this.DColorDistance = colorDistance;
	*}

	/**
	 * Gets Starting Color Distance Property
	 */	
	float getColorDistance() {*
		return this.DColorDistance;
	*}

	/**
	 * Sets Starting Color Hue Property
	 */	
	void setColorHue( /* Starting Color Hue */  int colorHue){*
		this.DColorHue = colorHue;
	*}

	/**
	 * Gets Starting Color Hue Property
	 */	
	int getColorHue() {*
		return this.DColorHue;
	*}

	/**
	 * Sets Starting Color Palette Property
	 */	
	void setColorPalette( /* Starting Color Palette */  choice colorPalette){*
		this.DColorPalette = colorPalette;
	*}

	/**
	 * Gets Starting Color Palette Property
	 */	
	choice getColorPalette() {*
		return this.DColorPalette;
	*}

	/**
	 * Sets Legend Position Property
	 */	
	void setLegendPosition( /* Legend Position */  choice legendPosition){*
		this.DLegendPosition = legendPosition;
	*}

	/**
	 * Gets Legend Position Property
	 */	
	choice getLegendPosition() {*
		return this.DLegendPosition;
	*}

	/**
	 * Sets Width of Legend in px Property
	 */	
	void setLegendWidth( /* Width of Legend in px */  int legendWidth){*
		this.DLegendWidth = legendWidth;
	*}

	/**
	 * Gets Width of Legend in px Property
	 */	
	int getLegendWidth() {*
		return this.DLegendWidth;
	*}

	/**
	 * Sets Maximum Number of Data Points Property
	 */	
	void setMaxDataPoints( /* Maximum Number of Data Points */  int maxDataPoints){*
		this.DMaxDataPoints = maxDataPoints;
	*}

	/**
	 * Gets Maximum Number of Data Points Property
	 */	
	int getMaxDataPoints() {*
		return this.DMaxDataPoints;
	*}

	/**
	 * Sets Show Legend Property
	 */	
	void setShowLegend( /* Show Legend */  boolean showLegend){*
		this.DShowLegend = showLegend;
	*}

	/**
	 * Gets Show Legend Property
	 */	
	boolean getShowLegend() {*
		return this.DShowLegend;
	*}

	/**
	 * Sets Swap Axes Property
	 */	
	void setSwapAxes( /* Swap Axes */  boolean swapAxes){*
		this.DSwapAxes = swapAxes;
	*}

	/**
	 * Gets Swap Axes Property
	 */	
	boolean getSwapAxes() {*
		return this.DSwapAxes;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

class org.scn.community.databound.Projector extends org.scn.community.shared.DataComponent {
	/**
	 * Sets data in serialized string form.  Meant to be used in conjunction with
	 * SCN Community Projection data component or another BYO Data component.
	 */
	void setDataString(/*String*/ String dataString){*
		this.data = dataString;
	*}
	/**
	 * Returns serialized string representing data.  Meant to be used with another
	 * SCN Community BYO Data component.
	 */
	String getDataString(){*
		return this.data;
	*}
	/**
	 * Returns projected serialized string representing data.  Meant to be used with another
	 * SCN Community BYO Data component.
	 */
	String getProjectedData(){*
		return this.projectedData;
	*}
	/**
	 * Returns dimension key being projected
	 */
	String getProjectDimension(){*
		return this.projectDimension;
	*}
	/**
	 * Sets dimension to project/aggregate
	 */
	String setProjectDimension(/*String*/ String dimension){*
		this.projectDimension = dimension;
		return this.projectedData;
	*}
	/**
	 * Returns projection/aggregation method
	 */
	String getProjectionMethod(){*
		return this.projectionMethod;
	*}
	/**
	 * Sets method to project/aggregate
	 * Valid type: (SUM,MIN,MAX,COUNT,AVG)
	 */
	String setProjectionMethod(/*String*/ String method){*
		this.projectionMethod = method;
		return this.projectedData;
	*}
}

/**
 * Class for DataRangeSlider
 */
class org.scn.community.databound.RangeSlider extends org.scn.community.shared.DataComponent {

	/** returns the selected key 
    <example>
	You want to get first and second selected key in the range
	<code>
    var selection1 = DATARANGESLIDER_1.getSelectedKey();
	var selection2 = DATARANGESLIDER_1.getSelectedKey2();
	
	APPLICATION.createInfoMessage("Selected Range: " + selection1 + " - " + selection2);
	APPLICATION.createInfoMessage("Selected Range Keys: " + DATARANGESLIDER_1.getSelectedKeys());
	
	if(selection1.indexOf("-N/A-") > -1 || selection2.indexOf("-N/A-") > -1) {
		// do nothing
	} else {
		DS_1.setFilterExt("0BC_PERS1", "" + DATARANGESLIDER_1.getSelectedKey()  + " - " + DATARANGESLIDER_1.getSelectedKey2());
	}
	</code>
	</example>
	*/
	String getSelectedKey () {*
		return this.selectedKey;	
	*}
	
	/** sets the selected key */
	void setSelectedKey (String key) {*
		this.selectedKey = key;	
	*}

	/** returns the selected key 2 */
	String getSelectedKey2 () {*
		return this.selectedKey2;	
	*}
	
	/** sets the selected key 2 */
	void setSelectedKey2 (String key2) {*
		this.selectedKey2 = key2;	
	*}
	
	/** sets the selected keys as String separated by ;
	 * This is compatible with setFilterExt function
	
 	<example>
	You want to get all selected keys in the range
	<code>
	var selectedKeys = DATARANGESLIDER_2.getSelectedKeys();<br>

	// remove the NAs, in this scenarios I do not care
	selectedKeys = Convert.replaceAll(selectedKeys, "-N/A-1;", "");<br>
	selectedKeys = Convert.replaceAll(selectedKeys, ";-N/A-2", "");<br>

	APPLICATION.createInfoMessage("Selected Range Keys: " + selectedKeys);<br>

	DS_1.setFilterExt("0BC_PERS1", selectedKeys);<br>
	</code>
	</example>
	*/

	String getSelectedKeys () {*
		return this.selectedKeys;	
	*}

	/** returns the selected text */
	String getSelectedText () {*
		return this.selectedText;	
	*}
	
	/** returns the selected text 2 */
	String getSelectedText2 () {*
		return this.selectedText2;	
	*}
	
	/** sets the pause refresh flag */
	void pauseRefresh () {*
		this.doRefresh = false;	
	*}

	/** sets the pause refresh flag */
	void allowRefresh () {*
		this.doRefresh = true;	
	*}
}

/**
 * Generated ZTL Class for Result Set Information
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.ResultSetInfo extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Central Data Provisioning Property
	 */	
	void setCentralProvisioning( /* Provision Data Centrally for Component Access */  boolean centralProvisioning){*
		this.DCentralProvisioning = centralProvisioning;
	*}

	/**
	 * Gets Central Data Provisioning Property
	 */	
	boolean getCentralProvisioning() {*
		return this.DCentralProvisioning;
	*}

	/**
	 * Sets Ignore Results Rows and Columns Property
	 */	
	void setIgnoreResults( /* Ignore Results Rows and Columns */  boolean ignoreResults){*
		this.DIgnoreResults = ignoreResults;
	*}

	/**
	 * Gets Ignore Results Rows and Columns Property
	 */	
	boolean getIgnoreResults() {*
		return this.DIgnoreResults;
	*}

	/**
	 * Sets Information Event Active Property
	 */	
	void setInformationEventActive( /* Send Data Information Event when data is available */  boolean informationEventActive){*
		this.DInformationEventActive = informationEventActive;
	*}

	/**
	 * Gets Information Event Active Property
	 */	
	boolean getInformationEventActive() {*
		return this.DInformationEventActive;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */
	/** Returns the information about number of cells */
	int getDataInfoNumberOfCells () {*
		return JSON.parse(this.DDataInformation).dataCells;
	*}

	/** Returns the information about number of data columns */
	int getDataInfoNumberOfDataColumns () {*
		return JSON.parse(this.DDataInformation).dataColumns;
	*}
	
	/** Returns the information about number of header columns */
	int getDataInfoNumberOfHeaderColumns () {*
		return JSON.parse(this.DDataInformation).headerColumns;
	*}
	
	/** Returns the information about number of rows */
	int getDataInfoNumberOfRows () {*
		return JSON.parse(this.DDataInformation).rows;
	*}
}

/**
 * Generated ZTL Class for Result Set Mixer
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.ResultSetMixer extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Collect Multiple Matches Property
	 */	
	void setCollectMultipleMatches( /* Procedure what should happen when multiple matches are available */  choice collectMultipleMatches){*
		this.DCollectMultipleMatches = collectMultipleMatches;
	*}

	/**
	 * Gets Collect Multiple Matches Property
	 */	
	choice getCollectMultipleMatches() {*
		return this.DCollectMultipleMatches;
	*}

	/**
	 * Sets Geometry of the Master Result Set Property
	 */	
	void setMasterGeometry( /* Geometry of the Master Result Set */  choice masterGeometry){*
		this.DMasterGeometry = masterGeometry;
	*}

	/**
	 * Gets Geometry of the Master Result Set Property
	 */	
	choice getMasterGeometry() {*
		return this.DMasterGeometry;
	*}

	/**
	 * Sets Master Central Data Provisioner Property
	 */	
	void setMasterProvisioner( /* Result Set with Master Data */  String masterProvisioner){*
		this.DMasterProvisioner = masterProvisioner;
	*}

	/**
	 * Gets Master Central Data Provisioner Property
	 */	
	String getMasterProvisioner() {*
		return this.DMasterProvisioner;
	*}

	/**
	 * Reloads the Component (with re-rendering)
	 */	
	void reload (){*
		this.DReloadTrigger = this.DReloadTrigger + 0.0001;
	*}

	/**
	 * Sets Column Condition to Read Slave Result Set Property
	 */	
	void setSlaveColumnCondition( /* Under which condition should be the slave result set read (based on contnet of header column key) */  String slaveColumnCondition){*
		this.DSlaveColumnCondition = slaveColumnCondition;
	*}

	/**
	 * Gets Column Condition to Read Slave Result Set Property
	 */	
	String getSlaveColumnCondition() {*
		return this.DSlaveColumnCondition;
	*}

	/**
	 * Sets Column Index for the Selection from Slave Result Set Property
	 */	
	void setSlaveColumnIndex( /* Which column should be selected from the slave result set */  int slaveColumnIndex){*
		this.DSlaveColumnIndex = slaveColumnIndex;
	*}

	/**
	 * Gets Column Index for the Selection from Slave Result Set Property
	 */	
	int getSlaveColumnIndex() {*
		return this.DSlaveColumnIndex;
	*}

	/**
	 * Sets Content Condition to Read Slave Result Set Property
	 */	
	void setSlaveContentCondition( /* Under which condition should be the slave result set read (based on content or value) */  String slaveContentCondition){*
		this.DSlaveContentCondition = slaveContentCondition;
	*}

	/**
	 * Gets Content Condition to Read Slave Result Set Property
	 */	
	String getSlaveContentCondition() {*
		return this.DSlaveContentCondition;
	*}

	/**
	 * Sets Slave Central Data Provisioner Property
	 */	
	void setSlaveProvisioner( /* Result Set with Slave Data for Selection */  String slaveProvisioner){*
		this.DSlaveProvisioner = slaveProvisioner;
	*}

	/**
	 * Gets Slave Central Data Provisioner Property
	 */	
	String getSlaveProvisioner() {*
		return this.DSlaveProvisioner;
	*}

	/**
	 * Sets Row Condition to Read Slave Result Set Property
	 */	
	void setSlaveRowCondition( /* Under which condition should be the slave result set read (based on contnet of header row key) */  String slaveRowCondition){*
		this.DSlaveRowCondition = slaveRowCondition;
	*}

	/**
	 * Gets Row Condition to Read Slave Result Set Property
	 */	
	String getSlaveRowCondition() {*
		return this.DSlaveRowCondition;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}

class org.scn.community.databound.ScatterPlot extends org.scn.community.shared.DataComponent {
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
	/**
	Set Hexagon Radius
	*/
	void setRadius(/*Radius (px)*/int radius) {*
		this.radius = radius;
	*}
	/**
	Get Hexagon Radius
	*/
	int getRadius() {*
		return this.radius;
	*}
	/**
	Set X-Axis Measure by text
	*/
	void setMeasureX(/*Measure*/String measure) {*
		this.measureX = measure;
	*}
	/**
	Get X-Axis Measure text
	*/
	String getMeasureX() {*
		return this.measureX;
	*}
	/**
	Set Y-Axis Measure by text
	*/
	void setMeasureY(/*Measure*/String measure) {*
		this.measureY = measure;
	*}
	/**
	Get Y-Axis Measure text
	*/
	String getMeasureY() {*
		return this.measureY;
	*}
	/**
	Set Y-Axis Min
	*/
	void setMinY(/*Minimume*/int min) {*
		this.minY = min;
	*}
	/**
	Get Y-Axis Min
	*/
	int getMinY() {*
		return this.minY;
	*}
	/**
	Set Y-Axis Max
	*/
	void setMaxY(/*Minimume*/int max) {*
		this.maxY = max;
	*}
	/**
	Get Y-Axis Max
	*/
	int getMaxY() {*
		return this.maxY;
	*}
	/**
	Set X-Axis Min
	*/
	void setMinX(/*Minimume*/int min) {*
		this.minX = min;
	*}
	/**
	Get X-Axis Min
	*/
	int getMinX() {*
		return this.minX;
	*}
	/**
	Set X-Axis Max
	*/
	void setMaxX(/*Minimume*/int max) {*
		this.maxX = max;
	*}
	/**
	Get X-Axis Max
	*/
	int getMaxX() {*
		return this.maxX;
	*}
}

/**
 * Class for DataSlider
 */
class org.scn.community.databound.Slider extends org.scn.community.shared.DataComponent {

	/** returns the selected key */
	String getSelectedKey () {*
		return this.selectedKey;	
	*}
	
	/** sets the selected key */
	void setSelectedKey (String key) {*
		this.selectedKey = key;	
	*}
	
	/** returns the selected text */
	String getSelectedText () {*
		return this.selectedText;	
	*}
	
	/** sets the pause refresh flag */
	void pauseRefresh () {*
		this.doRefresh = false;	
	*}

	/** sets the pause refresh flag */
	void allowRefresh () {*
		this.doRefresh = true;	
	*}
}

class org.scn.community.databound.Table2D extends org.scn.community.shared.DataComponent {
	
	/** returns the data */
	String getStringData () {*
		return this.stringData;	
	*}
}

/**
 * Class for Tag Cloud
 */

class org.scn.community.databound.tagCloud extends org.scn.community.shared.DataComponent {

/* Returns the Key of the currently selected Tree Element. */
	String getSelectedNodeKey() {*
		return this.selectedNode;
	*}
	
}

/**
 * Class for DataTopFlop
 */
class org.scn.community.databound.TopFlop extends org.scn.community.shared.DataComponent {

	/** returns the selected key */
	String getSelectedKey () {*
		return this.selectedKey;	
	*}
	
	/** sets the selected key */
	void setSelectedKey (String key) {*
		this.selectedKey = key;	
	*}

	/** returns the pressed key */
	String getPressedKey () {*
		return this.pressedKey;	
	*}
}

/**
 * Class for DataTopFlopChart
 */
class org.scn.community.databound.TopFlopChart extends org.scn.community.shared.DataComponent {

	/** returns the selected key */
	String getSelectedKey () {*
		return this.selectedKey;	
	*}
	
	/** sets the selected key */
	void setSelectedKey (String key) {*
		this.selectedKey = key;	
	*}

	/** returns the pressed key */
	String getPressedKey () {*
		return this.pressedKey;	
	*}
}

/**
 * Generated ZTL Class for UI5Table
 * 
 * DO NOT EDIT, ROOT SOURCE for custom functions in /spec/contribution.ztl
 */
class org.scn.community.databound.UI5Table extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Allow Reorder of Columns Property
	 */	
	void setAllowColumnReorder( /**Allow Reorder of Columns*/ boolean allowColumnReorder){*
		this.DAllowColumnReorder = allowColumnReorder;
	*}

	/**
	 * Gets Allow Reorder of Columns Property
	 */	
	boolean isAllowColumnReorder() {*
		return this.DAllowColumnReorder;
	*}

	/**
	 * Sets Allow Filter in Columns Property
	 */	
	void setAllowFilter( /**Allow Filter in Columns*/ boolean allowFilter){*
		this.DAllowFilter = allowFilter;
	*}

	/**
	 * Gets Allow Filter in Columns Property
	 */	
	boolean isAllowFilter() {*
		return this.DAllowFilter;
	*}

	/**
	 * Sets Allow Selection in the Table Property
	 */	
	void setAllowSelection( /**Allow Selection in the Table*/ boolean allowSelection){*
		this.DAllowSelection = allowSelection;
	*}

	/**
	 * Gets Allow Selection in the Table Property
	 */	
	boolean isAllowSelection() {*
		return this.DAllowSelection;
	*}

	/**
	 * Sets Allow Sort in Columns Property
	 */	
	void setAllowSort( /**Allow Sort in Columns*/ boolean allowSort){*
		this.DAllowSort = allowSort;
	*}

	/**
	 * Gets Allow Sort in Columns Property
	 */	
	boolean isAllowSort() {*
		return this.DAllowSort;
	*}

	/** Adds a root element containing key [String], width [String].

 	<example>
	You want to add 2 root elements
	<code>
	UI5TABLE.addColumnWidthEntry(key [String], width [String]);<br>
	UI5TABLE.addColumnWidthEntry(key [String], width [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addColumnWidthEntry (
			/**Column index (0-based)*/String key, 
			/**Width with unit (e.g. 200px | 30%)*/String width
			) {*		
		
		
		var itemDef = {
			leaf:true,
			key:key, 
			width:width
			};
	
		if (this.DDataColWidths === undefined || this.DDataColWidths === "" || this.DDataColWidths === "<delete>"){
			this.DDataColWidths = "[]";
		}
		
		var elementsJson = JSON.parse(this.DDataColWidths);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.DDataColWidths = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	UI5TABLE.removeColumnWidthEntry(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeColumnWidthEntry (
			String key
			) {*		
		
		if (this.DDataColWidths === undefined || this.DDataColWidths === "" || this.DDataColWidths === "<delete>"){
			this.DDataColWidths = "[]";
		}
		
		var elementsJson = JSON.parse(this.DDataColWidths);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.DDataColWidths = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets Central Result Set with Data Property
	 */	
	void setDataProvisioner( /**Central Result Set with Data*/ String dataProvisioner){*
		this.DDataProvisioner = dataProvisioner;
	*}

	/**
	 * Gets Central Result Set with Data Property
	 */	
	String getDataProvisioner() {*
		return this.DDataProvisioner;
	*}

	/**
	 * Sets Empty Value For Data Cell Property
	 */	
	void setEmptyDataValue( /**Empty Value For Data Cell*/ String emptyDataValue){*
		this.DEmptyDataValue = emptyDataValue;
	*}

	/**
	 * Gets Empty Value For Data Cell Property
	 */	
	String getEmptyDataValue() {*
		return this.DEmptyDataValue;
	*}

	/**
	 * Sets Empty Value For Header Cell Property
	 */	
	void setEmptyHeaderValue( /**Empty Value For Header Cell*/ String emptyHeaderValue){*
		this.DEmptyHeaderValue = emptyHeaderValue;
	*}

	/**
	 * Gets Empty Value For Header Cell Property
	 */	
	String getEmptyHeaderValue() {*
		return this.DEmptyHeaderValue;
	*}

	/**
	 * Sets Fix Header Rows Property
	 */	
	void setFixedHeader( /**Fix Header Rows*/ boolean fixedHeader){*
		this.DFixedHeader = fixedHeader;
	*}

	/**
	 * Gets Fix Header Rows Property
	 */	
	boolean isFixedHeader() {*
		return this.DFixedHeader;
	*}

	/**
	 * Sets (non-stable) Formatting Condition Property
	 */	
	void setFormattingCondition( /**(non-stable) Formatting Condition*/ String formattingCondition){*
		this.DFormattingCondition = formattingCondition;
	*}

	/**
	 * Gets (non-stable) Formatting Condition Property
	 */	
	String getFormattingCondition() {*
		return this.DFormattingCondition;
	*}

	/**
	 * Sets (non-stable) Formatting Operator Property by String
	 */	
	void setFormattingOperatorByString( /**(non-stable) Formatting Operator*/ String formattingOperator){*
		this.DFormattingOperator = formattingOperator;
	*}

	/**
	 * Gets (non-stable) Formatting Operator Property as String
	 */	
	String getFormattingOperatorAsString() {*
		return this.DFormattingOperator;
	*}

	/**
	 * Sets Header Column Width in px Property
	 */	
	void setHeaderColWidth( /**Header Column Width in px*/ int headerColWidth){*
		this.DHeaderColWidth = headerColWidth;
	*}

	/**
	 * Gets Header Column Width in px Property
	 */	
	int getHeaderColWidth() {*
		return this.DHeaderColWidth;
	*}

	/**
	 * Sets Ignore Results Property
	 */	
	void setIgnoreResults( /**Ignore Results*/ boolean ignoreResults){*
		this.DIgnoreResults = ignoreResults;
	*}

	/**
	 * Gets Ignore Results Property
	 */	
	boolean isIgnoreResults() {*
		return this.DIgnoreResults;
	*}

	/**
	 * Sets Navigation Mode Property by String
	 */	
	void setNavigationModeByString( /**Navigation Mode*/ String navigationMode){*
		this.DNavigationMode = navigationMode;
	*}

	/**
	 * Gets Navigation Mode Property as String
	 */	
	String getNavigationModeAsString() {*
		return this.DNavigationMode;
	*}

	/**
	 * Sets Row Height in px Property
	 */	
	void setRowHeight( /**Row Height in px*/ int rowHeight){*
		this.DRowHeight = rowHeight;
	*}

	/**
	 * Gets Row Height in px Property
	 */	
	int getRowHeight() {*
		return this.DRowHeight;
	*}



	/**
	 * Sets Visible Row Count Property
	 */	
	void setVisibleRowCount( /**Visible Row Count*/ int visibleRowCount){*
		this.DVisibleRowCount = visibleRowCount;
	*}

	/**
	 * Gets Visible Row Count Property
	 */	
	int getVisibleRowCount() {*
		return this.DVisibleRowCount;
	*}








	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */
	/**
	 * Gets Selection As JSON String
	 */	
	String getSelectionAsJSON() {*
		var jsonObject = JSON.parse(this.DSelection);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Gets Selection As JSON String
	 */	
	JSON getSelectionAsJSONObject() {*
		var jsonObject = JSON.parse(this.DSelection);
		return JSON.stringify(jsonObject, null, 4);
	*}

	/**
	 * Selected Row Index (0 - based)
	 */
	int getSelectedRow() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.row;
	*}
	
	/**
	 * Selected Column Index (0 - based)
	 */
	int getSelectedColumn() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.column;
	*}

	/**
	 * Selected Visual Row Index (0 - based)
	 */
	int getSelectedVisualRow() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.visualRow;
	*}
	
	/**
	 * Selected Visual Column Index (0 - based)
	 */
	int getSelectedVisualColumn() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.visualColumn;
	*}

	/**
	 * Selected Value Content
	 */
	int getSelectedValue() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.value;
	*}
	
	/**
	 * Selection Space (Header, Data)
	 */
	String getSelectionSpace() {*
		var jsonObject = JSON.parse(this.DSelection);
		return jsonObject.value;
	*}

	/**
	 * Return dimensions and corresponding members for the selection as array
	 */
	org.scn.community.shared.DimensionMemberArray getSelectionDimensionMembers() {*
		var jsonObject = JSON.parse(this.DSelection);
		
		var tempA = [];
		
		for(var i=0;i<jsonObject.rowDimensions.length;i++){
			var itemDef = { 
				"dimension": jsonObject.rowDimensions[i].key, 
				"member": jsonObject.rowKeys[i]
			};
			
			tempA.push(itemDef);
		}
		
		if(jsonObject.columnDimensions) {
			for(var i=0;i<jsonObject.columnDimensions.length;i++){
				var itemDef = { 
					"dimension": jsonObject.columnDimensions[i].key, 
					"member": jsonObject.columnKeys[i]
				};
				
				tempA.push(itemDef);
			}
		}
		
		return tempA;
	*}

	/**
	 * Values of the Row
	 */
	StringArray getSelectionRowValues() {*
		var jsonObject = JSON.parse(this.DSelection);
		
	
		var tempA = [];
		for(var i=0;i<jsonObject.rowValues.length;i++){
			var itemDef = jsonObject.rowValues[i];
			
			tempA.push(itemDef);
		}

		return tempA;
	*}
}
