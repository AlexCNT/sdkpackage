/* GENERATED - DO NOT EDIT */
/**
 * Copyright 2014, Contributors
 * 
 * Original Source Code Location:
 *  https://github.com/org-scn-design-studio-community/sdkpackage/
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */

class org.scn.community.databound.Choropleth extends org.scn.community.shared.Component {
	/**
	Get selected feature
	*/
	String getSelectedFeature() {*
		return this.selectedFeature;
	*}
	/**
	Set Measure to use for coloring
	*/
	void setMeasure(/*Measure*/String measure) {*
		return this.measureMember = measure;
	*}
	/**
	Set Projection Method
	*/
	void setProjection(/*Projection*/String projection) {*
		this.projection = projection;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		return this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
}
class org.scn.community.databound.Table extends org.scn.community.shared.DataComponent {

	/* Sets the data displayed in the first column. */
	void setColumn1Selection(/* A selection specifying a single column (or row) of keyfigures from a data source */ ResultCellListSelection selection) {*
		this.column1 = this.stringifySelection(selection);
	*}

	/* Sets the data displayed in the second column. */
	void setColumn2Selection(/* A selection specifying a single column (or row) of keyfigures from a data source */ ResultCellListSelection selection) {*
		this.column2 = this.stringifySelection(selection);
	*}

	/* Sets the data displayed in the third column. */
	void setColumn3Selection(/* A selection specifying a single column (or row) of keyfigures from a data source */ ResultCellListSelection selection) {*
		this.column3 = this.stringifySelection(selection);
	*}
}

/**
 * Class for DataDropDown
 */
class org.scn.community.databound.DropDown extends org.scn.community.shared.DataComponent {

	void private_onSelectionChanged () {*
		var key = this.getSelectedKey();
	
		this.internalWriteLog("Internal Selection on Dimension: " + this.getDimension() + " | " + key);

		if(key == "-CLEAR-") {
			this.getDataSource().clearFilter(this.getDimension());
		} else {
			this.getDataSource().setFilter(this.getDimension(), key);	
		}
	*}
	
	void private_onBeforeRender() {*
		
	*}
	
	void reloadDataSource() {*
		// unfortunately this does not work correctly as this method is too late included (as first method on rendering, instead on before rendering)
		// this causes incorrect events in a phase where events are not allowed any more... (error: DS_1 cannot be changed in rendering phase)
		// workaround is to call once explicitelly "getMembers" on this dimension
		if(this.DBindingMode == "Master Data") {
			this.internalWriteLog("Call Members on Dimension: " + this.getDimension() + " | " + this.DMaxMembers);
			this.DElements = this.superReadMembers(this.getDimension(), this.DMaxMembers);	
		}
	
		// check current selection from data source
		var selectionExt = this.getDataSource().getFilterExt(this.getDimension());
		this.internalWriteLog("Selection on Dimension: " + this.getDimension() + " | " + selectionExt);

		this.DSelectedKeyExtFull = selectionExt;
		
		// only single member
		if(selectionExt.indexOf(";") == -1 && selectionExt.indexOf(" - ") == -1) {
			this.DSelectedKeyExt = selectionExt;	
		} else {
			this.DSelectedKeyExt = "";
		}
	*}

	/** returns the selected key 
    <example>
	You want to get first and second selected key in the range
	<code>
    var selection1 = DATARANGESLIDER_1.getSelectedKey();
	var selection2 = DATARANGESLIDER_1.getSelectedKey2();
	
	APPLICATION.createInfoMessage("Selected Range: " + selection1 + " - " + selection2);
	APPLICATION.createInfoMessage("Selected Range Keys: " + DATARANGESLIDER_1.getSelectedKeys());
	
	if(selection1.indexOf("-N/A-") > -1 || selection2.indexOf("-N/A-") > -1) {
		// do nothing
	} else {
		DS_1.setFilterExt("0BC_PERS1", "" + DATARANGESLIDER_1.getSelectedKey()  + " - " + DATARANGESLIDER_1.getSelectedKey2());
	}
	</code>
	</example>
	*/
	String getSelectedKey () {*
		return this.DSelectedKey;	
	*}

	/** returns the selected text */
	String getSelectedText () {*
		return this.DSelectedText;	
	*}
	
	/** gest the dimension */
	String getDimension () {*
		return this.DDimension;	
	*}
	
	/** sets the dimension */
	void setDimension (String dimension) {*
		this.DDimension = dimension;	
	*}
	
	/** sets the pause refresh flag */
	void pauseRefresh () {*
		this.DDoRefresh = false;	
	*}

	/** sets the pause refresh flag */
	void allowRefresh () {*
		this.DDoRefresh = true;	
	*}
}

/**
 * Class for D3Hier
 */
class org.scn.community.databound.jpd3hier extends org.scn.community.shared.DataComponent {

	/* Returns the Key of the currently selected Tree Element. */
	String getSelectedNodeKey() {*
		return this.selectedNode;
	*}
	
	/* Returns the Dimension Key containing the hierarchy of the datasource. */
	String getHierarchyDimensionKey() {*
		return this.dimHierarchy;
	*}
	
	/* Returns the maximum Size of the Bubbles in Pixel */
	String getBubbleSizeMaxSize() {*
		return this.BubbleSizeMaxSize;
	*}
	
	/* Sets the maximum Size of the Bubbles in Pixel */
	void setBubbleSizeMaxSize(/* New maximum Bubble size in Pixel */ int newBubbleSize) {*
		this.BubbleSizeMaxSize = newBubbleSize;
	*}
	
	/* Sets the Bubble Size Keyfigure id during runtime */
	void setkfBubbleSize(/* New id of a keyfigure column */ String newkfBubbleSizeId) {*
		this.kfBubbleSize = newkfBubbleSizeId;
	*}
	
	/* Gets the Bubble Size Keyfigure id during runtime */
	void getkfBubbleSize() {*
		return this.kfBubbleSize;
	*}
	
	/* Sets the Bubble Alerter Keyfigure id during runtime */
	void setkfBubbleAlerter(/* New id of a keyfigure column */ String newkfBubbleAlerterId) {*
		this.kfColBub = newkfBubbleAlerterId;
	*}
	
	/* Gets the Bubble Alerter Keyfigure id during runtime */
	void getkfBubbleAlerter() {*
		return this.kfColBub;
	*}
	
	/* Sets the Bubble Alerter Color Value for Green during runtime */
	void setAlerterColorGreenVal(/* New value for the Bubble color Green*/ int newAlerterColorGreenVal) {*
		this.AlerterColorGreenVal = newAlerterColorGreenVal;
	*}
	
	/* Sets the Bubble Alerter Color Value for Yellow during runtime */
	void setAlerterColorYellowVal(/* New value for the Bubble color Yellow*/ int newAlerterColorYellowVal) {*
		this.AlerterColorYellowVal = newAlerterColorYellowVal;
	*}
	
	/* Returns the x-translation of the whole tree in Pixel */
	String getBubbleRootXTranslation() {*
		return this.BubbleRootXTranslation;
	*}
	/* Sets the x-translation of the whole tree in Pixel */
	void setBubbleRootXTranslation(/* New x translation in Pixel -> positive = right, negative = left*/ int newXTranslation) {*
		this.BubbleRootXTranslation = newXTranslation;
	*}
	
	/* Expand the hierarchy (used for DS 1.4 private functionality) - it seems that the private call does not work */
	@Visibility(private) 
	void expandHierarchyNode() {*
	    this.getDataSource().expandNode(this.getHierarchyDimensionKey(), this.getSelectedNodeKey());
	*}
	
	/* Collapse the hierarchy (used for DS 1.4 private functionality) - it seems that the private call does not work */
	@Visibility(private) 
	void collapseHierarchyNode() {*
		this.getDataSource().collapseNode(this.getHierarchyDimensionKey(), this.getSelectedNodeKey());
	*}
	
	/* Expand the hierarchy */
	void expandHierarchyNodes() {*
	    this.getDataSource().expandNode(this.getHierarchyDimensionKey(), this.getSelectedNodeKey());
	*}
	
	/* Collapse the hierarchy */
	void collapseHierarchyNodes() {*
		this.getDataSource().collapseNode(this.getHierarchyDimensionKey(), this.getSelectedNodeKey());
	*}
	
}

/**
 * Class for DataDropDown
 */
class org.scn.community.databound.FacetFilter extends org.scn.community.shared.DataComponent {
	
	/**
	 * Returns the value of max members property
	 */
	int getMaxMembers() {*
		return this.DMaxMembers;
	*}

	/**
	 * Sets the value of max members property
	 */
	void setMaxMembers(int value) {*
		this.DMaxMembers = value;
	*}
	
	/**
	 * Returns the value of clear others
	 */
	boolean getClearOthers() {*
		return this.DClearOthers;
	*}

	/**
	 * Sets the value of clear others
	 */
	void setClearOthers(boolean value) {*
		this.DClearOthers = value;
	*}
	
	/**
	 * Sets the value of max members property
	 */
	void setCustomDimensions(StringArray value) {*
		this.DCustomDimensions = JSON.stringify(value);
	*}

	/**
	 * DO NOT USE PRIVATE METHODS
	 */
	void private_onSelectionChanged () {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.selection = this.DSelection;
	
		l.selectionJson = JSON.parse(l.selection);
		
		l.dimensionName = l.selectionJson.dimension;
		l.keys = l.selectionJson.keys;
		
		l.keysAsArray = [];

		l.DS = this.getDataSource();
		
		if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		
		if(l.DS) {
			if(l.selectionJson.clearOthers && that.getClearOthers()) {
				this.private_readDimensions(l.DS);
				l.dimensions = this._tempDimensions;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(this, l)};
				
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						l.currentDimensionName = dimension.name
						if(l.currentDimensionName != l.dimensionName) {
							l.DS.clearFilter(l.currentDimensionName);
						}
					}
				});
			}
			
			if(l.keys.length == 1 && l.keys[0] == "-ALL-") {
				l.DS.clearFilter(l.dimensionName);
			} else {
				for (var iK = 0; iK < l.keys.length; iK++) {
					l.key = l.keys[iK];
					
					l.keysAsArray.push(l.key);
				}
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
				
				l.DS.setFilter(l.dimensionName, l.keysAsArray);
			}
		}
		
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
	*}

	/**
	 * 
	 */
	void private_readDimensions (Object dataSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		if(this.DContentMode == "Only from Result Set") {
			l.dimensionsRows = dataSource.getDimensions(Axis.ROWS);
			l.dimensionsColumns = dataSource.getDimensions(Axis.COLUMNS);
			
			l.dimensions = [];

			l.dimensionsRows.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});	
			l.dimensionsColumns.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		} else if(this.DContentMode == "Custom Dimension Set") {
			l.dimensionsAll = dataSource.getDimensions();
			l.customDimensions = JSON.parse(that.DCustomDimensions);
			
			l.customDimensionsFlat = "|";
			for (var iD = 0; iD < l.customDimensions.length; iD++) {
				l.customDimensionsFlat = l.customDimensionsFlat + l.customDimensions[iD] + "|";
			}
			
			l.dimensions = [];
			
			l.dimensionsAll.forEach(function(dimension, indexD) {
				l.currentAvailableDimensionName = dimension.name; 
				if(l.customDimensionsFlat.indexOf("|" + l.currentAvailableDimensionName + "|") > -1) {
					l.dimensions.push(dimension);
				}
			});	
		} else {
			l.dimensions = dataSource.getDimensions();
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
		
		this._tempDimensions = l.dimensions;
	*}
	
	/**
	 * DO NOT USE PRIVATE METHODS
	 */
	void private_onBeforeRender() {*
	*}
	
	/**
	 * This function must be used for initialization and in case the drilldown structure has been changed.
	 * You should trigger it once and ideally when filters are NOT set on dimensions, other case you will see only members which are available in resultset (depends on your setting "member selection" on dimension level).
	 * When to use this method?
	 * - As soon the Data Source is initialized, either in "onStartup()" script or after loading in script.
	 * <example>
	 * You have loaded the data source and want to initialize.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACETFILTER_1.reloadDataSource();
	 * FACETFILTER_1.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACETFILTER_1.reloadDataSource(DS_FULL);
	 * FACETFILTER_1.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadDataSource(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.elementsJson = [];

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}

		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensionKeys = "";
			l.dimensions.forEach(function(dimension, index) {
				l.dimensionKeys = l.dimensionKeys + dimension.name;
			});
			
			if(this.oldDimensionKeys != l.dimensionKeys) {
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						// warnings to assure query is ok
						if(l.DS.isHierarchyActive(dimension)) {
							APPLICATION.createWarningMessage("Data Source has an Active Hierarchy on Dimension: " + dimension.name);
						}
	
						l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());
	
						l.dimensionJson = {};
						l.dimensionJson.name = dimension.name;
						l.dimensionJson.text = dimension.text;
						l.dimensionJson.isMeasuresDimension = dimension.isMeasuresDimension;
	
						l.dimensionJson.hierarchyActive = l.DS.isHierarchyActive(dimension);
						l.dimensionJson.filterExt = ";" + l.DS.getFilterExt(dimension);
						
						l.dimensionJson.members = l.members;
			
						l.elementsJson.push(l.dimensionJson);
					}
				});

				this.DElements = JSON.stringify(l.elementsJson);
				this.oldDimensionKeys = l.dimensionKeys;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			}
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}
	
	/**
	 * This function can be used after the filter in data source was changed to update the component.
	 * You should be trigered every time the filter change occurs, therefore the event in Data Source -> onResultSetChanged() is a good place.
	 * When to use this method?
	 * - Always the filter is changed, also the "onResultSetChanged()" event is good for this.
	 * <example>
	 * You want to keep the selections with data source.
	 * The code should be placed in "onResultSetChanged()" method.
	 * <code>
	 * // if you want to update also dimensions when drilldown is changed
	 * FACETFILTER_1.reloadDataSource();
	 * 
	 * // every time 
	 * FACETFILTER_1.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACETFILTER_1.reloadDataSource(DS_FULL);
	 * FACETFILTER_1.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadSelection(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/
	
		l.elementsJson = {};

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}
		
		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensions.forEach(function(dimension, indexD) {
				l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());

				l.dimensionJson = {};
				l.dimensionJson.name = dimension.name;
				l.dimensionJson.members = [];
				l.dimensionJson.filterExt = "; " + l.DS.getFilterExt(dimension) + ";";

				l.elementsJson[dimension.name] = l.dimensionJson;
			});

			this.DSelection = JSON.stringify(l.elementsJson);
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		}
		
		/* exiting general block*/
		if(this.isDebug("DEBUG_2")) { DEBUG_2.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}
	
	/**
	 * Sets the sorting direction - ASCENDING | DESCENDING
	 */
	void setSortingDirection (org_scn_community_shared_SortDirectionEnumfield direction) {*
		if(direction == org_scn_community_shared_SortDirection.ASCENDING) {
			this.DSortingType = "Ascending";
			return;
		}
		if(direction == org_scn_community_shared_SortDirection.DESCENDING) {
			this.DSortingType = "Descending";
			return;
		}
		this.DSortingType = "Ascending";
	*}
	
	/**
	 * Sets the sorting type - DEFAULT | ALPHABETICAL | VALUE | SELECTED
	 */
	void setSortingType (org_scn_community_shared_SortTypeEnumfield type) {*
		if(type == org_scn_community_shared_SortType.DEAFULT) {
			this.DSortingType = "Default";
			return;
		}
		if(type == org_scn_community_shared_SortType.VALUE) {
			this.DSortingType = "Value";
			return;
		}
		if(type == org_scn_community_shared_SortType.ALPHABETICAL) {
			this.DSortingType = "Alphabetical";
			return;
		}
		if(type == org_scn_community_shared_SortType.SELECTED) {
			this.DSortingType = "Selected";
			return;
		}
		this.DSortingType = "Default";
	*}
	
	/**
	 * Sets the sorting type - ALL | RESULTSET | CUSTOM
	 */
	void setContentMode (org_scn_community_shared_ContentModeEnumfield mode) {*
		if(mode == org_scn_community_shared_ContentMode.ALL) {
			this.DContentMode = "All Dimensions";
			return;
		}
		if(mode == org_scn_community_shared_ContentMode.RESULTSET) {
			this.DContentMode = "Only from Result Set";
			return;
		}
		if(mode == org_scn_community_shared_ContentMode.CUSTOM) {
			this.DContentMode = "Custom Dimension Set";
			return;
		}
		this.DContentMode = "Only from Result Set";
	*}
	
	void setCustomDimensions (StringArray dimensions) {*
		this.DCustomDimensions = JSON.stringify(dimensions);
	*}
	
	/**
	 * Sets simple selection for dynamic use, you can place here some measure (member of measure dimension)
	 */
	void setSimpleSelection(String dimension, String member) {*
		this.data = "{\""+dimension+"\": \""+member+"\"}";
	*}
}
/**
 * enum field definition
 */
class org_scn_community_shared_ThresholdMethod extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_ThresholdMethodTypes extends Enum {

	/** CHECKED */
	org_scn_community_shared_ThresholdMethod CHECKED;
       
	/** UNCHECKED */
	org_scn_community_shared_ThresholdMethod UNCHECKED;

	/** MIXED */
	org_scn_community_shared_ThresholdMethod MIXED;
}


class org.scn.community.databound.HexBin extends org.scn.community.shared.DataComponent {
	/**
	Set Threshold Method
	*/
	void setThresholdMethod(/*Method*/ String method) {*
		this.thresholdMethod = method;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
	/**
	Set Hexagon Radius
	*/
	void setRadius(/*Radius (px)*/int radius) {*
		this.radius = radius;
	*}
	/**
	Get Hexagon Radius
	*/
	int getRadius() {*
		return this.radius;
	*}
	/**
	Set Max Threshold
	*/
	void setThreshold(/*Threshold*/int threshold) {*
		this.threshold = threshold;
	*}
	/**
	Get Max Threshold
	*/
	int getThreshold() {*
		return this.threshold;
	*}
	/**
	Set Min Threshold (Tolerance)
	*/
	void setTolerance(/*Tolerance*/int tolerance) {*
		this.tolerance = tolerance;
	*}
	/**
	Get Min Threshold (Tolerance)
	*/
	int getTolerance() {*
		return this.tolerance;
	*}
	/**
	Set X-Axis Measure by text
	*/
	void setMeasureX(/*Measure*/String measure) {*
		this.measureX = measure;
	*}
	/**
	Get X-Axis Measure text
	*/
	String getMeasureX() {*
		return this.measureX;
	*}
	/**
	Set Y-Axis Measure by text
	*/
	void setMeasureY(/*Measure*/String measure) {*
		this.measureY = measure;
	*}
	/**
	Get Y-Axis Measure text
	*/
	String getMeasureY() {*
		return this.measureY;
	*}
	/**
	Set Y-Axis Min
	*/
	void setMinY(/*Minimume*/int min) {*
		this.minY = min;
	*}
	/**
	Get Y-Axis Min
	*/
	int getMinY() {*
		return this.minY;
	*}
	/**
	Set Y-Axis Max
	*/
	void setMaxY(/*Minimume*/int max) {*
		this.maxY = max;
	*}
	/**
	Get Y-Axis Max
	*/
	int getMaxY() {*
		return this.maxY;
	*}
	/**
	Set X-Axis Min
	*/
	void setMinX(/*Minimume*/int min) {*
		this.minX = min;
	*}
	/**
	Get X-Axis Min
	*/
	int getMinX() {*
		return this.minX;
	*}
	/**
	Set X-Axis Max
	*/
	void setMaxX(/*Minimume*/int max) {*
		this.maxX = max;
	*}
	/**
	Get X-Axis Max
	*/
	int getMaxX() {*
		return this.maxX;
	*}
}

/**
 * Class for DataLeaderBoard
 */
class org.scn.community.databound.LeaderBoard extends org.scn.community.shared.DataComponent {

	/** returns the selected key */
	String getSelectedKey () {*
		return this.selectedKey;	
	*}
	
	/** sets the selected key */
	void setSelectedKey (String key) {*
		this.selectedKey = key;	
	*}

	/** returns the pressed key */
	String getPressedKey () {*
		return this.pressedKey;	
	*}
}

class org.scn.community.databound.MarimekkoChart extends org.scn.community.shared.DataComponent {
	/**
	Get selected row
	*/
	String getSelectedRow() {*
		return this.selectedRow;
	*}
	/**
	Get selected column
	*/
	String getSelectedColumn() {*
		return this.selectedColumn;
	*}
	/**
	Get selected value
	*/
	float getSelectedValue() {*
		return this.selectedValue;
	*}
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		return this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
}

class org.scn.community.databound.MultiLevelDropDown extends org.scn.community.shared.DataComponent {
	Boolean getAddSingleRootNode() {*
		return this.addSingleRootNode;
	*}

	void setAddSingleRootNode(Boolean value) {*
		this.addSingleRootNode = value;
	*}
	
	String getSingleRootName() {*
		return this.singleRootName;
	*}

	void setSingleRootName(String newName) {*
		this.singleRootName = newName;
	*}
	
	String getClickedElemKey() {*
		return this.clickedElemKey;
	*}

	void setClickedElemKey(String clicked) {*
		this.clickedElemKey = clicked;
	*}
	
	String getResetButton() {*
		return this.resetButton;
	*}

	void setResetButton(String value) {*
		this.resetButton = value;
	*}

	String getDimension() {*
		return this.selChar;
	*}

	void setDimension(String value) {*
		this.selChar = value;
	*}

}

class org.scn.community.databound.Projector extends org.scn.community.shared.DataComponent {
	/**
	 * Sets data in serialized string form.  Meant to be used in conjunction with
	 * SCN Community Projection data component or another BYO Data component.
	 */
	void setDataString(/*String*/ String dataString){*
		this.data = dataString;
	*}
	/**
	 * Returns serialized string representing data.  Meant to be used with another
	 * SCN Community BYO Data component.
	 */
	String getDataString(){*
		return this.data;
	*}
	/**
	 * Returns projected serialized string representing data.  Meant to be used with another
	 * SCN Community BYO Data component.
	 */
	String getProjectedData(){*
		return this.projectedData;
	*}
	/**
	 * Returns dimension key being projected
	 */
	String getProjectDimension(){*
		return this.projectDimension;
	*}
	/**
	 * Sets dimension to project/aggregate
	 */
	String setProjectDimension(/*String*/ String dimension){*
		this.projectDimension = dimension;
		return this.projectedData;
	*}
	/**
	 * Returns projection/aggregation method
	 */
	String getProjectionMethod(){*
		return this.projectionMethod;
	*}
	/**
	 * Sets method to project/aggregate
	 * Valid type: (SUM,MIN,MAX,COUNT,AVG)
	 */
	String setProjectionMethod(/*String*/ String method){*
		this.projectionMethod = method;
		return this.projectedData;
	*}
}

/**
 * Class for DataRangeSlider
 */
class org.scn.community.databound.RangeSlider extends org.scn.community.shared.DataComponent {

	/** returns the selected key 
    <example>
	You want to get first and second selected key in the range
	<code>
    var selection1 = DATARANGESLIDER_1.getSelectedKey();
	var selection2 = DATARANGESLIDER_1.getSelectedKey2();
	
	APPLICATION.createInfoMessage("Selected Range: " + selection1 + " - " + selection2);
	APPLICATION.createInfoMessage("Selected Range Keys: " + DATARANGESLIDER_1.getSelectedKeys());
	
	if(selection1.indexOf("-N/A-") > -1 || selection2.indexOf("-N/A-") > -1) {
		// do nothing
	} else {
		DS_1.setFilterExt("0BC_PERS1", "" + DATARANGESLIDER_1.getSelectedKey()  + " - " + DATARANGESLIDER_1.getSelectedKey2());
	}
	</code>
	</example>
	*/
	String getSelectedKey () {*
		return this.selectedKey;	
	*}
	
	/** sets the selected key */
	void setSelectedKey (String key) {*
		this.selectedKey = key;	
	*}

	/** returns the selected key 2 */
	String getSelectedKey2 () {*
		return this.selectedKey2;	
	*}
	
	/** sets the selected key 2 */
	void setSelectedKey2 (String key2) {*
		this.selectedKey2 = key2;	
	*}
	
	/** sets the selected keys as String separated by ;
	 * This is compatible with setFilterExt function
	
 	<example>
	You want to get all selected keys in the range
	<code>
	var selectedKeys = DATARANGESLIDER_2.getSelectedKeys();<br>

	// remove the NAs, in this scenarios I do not care
	selectedKeys = Convert.replaceAll(selectedKeys, "-N/A-1;", "");<br>
	selectedKeys = Convert.replaceAll(selectedKeys, ";-N/A-2", "");<br>

	APPLICATION.createInfoMessage("Selected Range Keys: " + selectedKeys);<br>

	DS_1.setFilterExt("0BC_PERS1", selectedKeys);<br>
	</code>
	</example>
	*/

	String getSelectedKeys () {*
		return this.selectedKeys;	
	*}

	/** returns the selected text */
	String getSelectedText () {*
		return this.selectedText;	
	*}
	
	/** returns the selected text 2 */
	String getSelectedText2 () {*
		return this.selectedText2;	
	*}
	
	/** sets the pause refresh flag */
	void pauseRefresh () {*
		this.doRefresh = false;	
	*}

	/** sets the pause refresh flag */
	void allowRefresh () {*
		this.doRefresh = true;	
	*}
}

class org.scn.community.databound.ScatterPlot extends org.scn.community.shared.DataComponent {
	/**
	Set Legend Visibility
	*/
	void setLegendVisible(/*Visible*/boolean visible) {*
		this.legendOn = visible;
	*}
	/**
	Set Color Palette
	*/
	void setColorPalette(/*Color Palette*/String palette) {*
		this.colorPalette = palette;
	*}
	/**
	Set Hexagon Radius
	*/
	void setRadius(/*Radius (px)*/int radius) {*
		this.radius = radius;
	*}
	/**
	Get Hexagon Radius
	*/
	int getRadius() {*
		return this.radius;
	*}
	/**
	Set X-Axis Measure by text
	*/
	void setMeasureX(/*Measure*/String measure) {*
		this.measureX = measure;
	*}
	/**
	Get X-Axis Measure text
	*/
	String getMeasureX() {*
		return this.measureX;
	*}
	/**
	Set Y-Axis Measure by text
	*/
	void setMeasureY(/*Measure*/String measure) {*
		this.measureY = measure;
	*}
	/**
	Get Y-Axis Measure text
	*/
	String getMeasureY() {*
		return this.measureY;
	*}
	/**
	Set Y-Axis Min
	*/
	void setMinY(/*Minimume*/int min) {*
		this.minY = min;
	*}
	/**
	Get Y-Axis Min
	*/
	int getMinY() {*
		return this.minY;
	*}
	/**
	Set Y-Axis Max
	*/
	void setMaxY(/*Minimume*/int max) {*
		this.maxY = max;
	*}
	/**
	Get Y-Axis Max
	*/
	int getMaxY() {*
		return this.maxY;
	*}
	/**
	Set X-Axis Min
	*/
	void setMinX(/*Minimume*/int min) {*
		this.minX = min;
	*}
	/**
	Get X-Axis Min
	*/
	int getMinX() {*
		return this.minX;
	*}
	/**
	Set X-Axis Max
	*/
	void setMaxX(/*Minimume*/int max) {*
		this.maxX = max;
	*}
	/**
	Get X-Axis Max
	*/
	int getMaxX() {*
		return this.maxX;
	*}
}

/**
 * Class for DataSlider
 */
class org.scn.community.databound.Slider extends org.scn.community.shared.DataComponent {

	/** returns the selected key */
	String getSelectedKey () {*
		return this.selectedKey;	
	*}
	
	/** sets the selected key */
	void setSelectedKey (String key) {*
		this.selectedKey = key;	
	*}
	
	/** returns the selected text */
	String getSelectedText () {*
		return this.selectedText;	
	*}
	
	/** sets the pause refresh flag */
	void pauseRefresh () {*
		this.doRefresh = false;	
	*}

	/** sets the pause refresh flag */
	void allowRefresh () {*
		this.doRefresh = true;	
	*}
}

class org.scn.community.databound.Table2D extends org.scn.community.shared.DataComponent {
	
	/** returns the data */
	String getStringData () {*
		return this.stringData;	
	*}
}

/**
 * Class for DataTopFlop
 */
class org.scn.community.databound.TopFlop extends org.scn.community.shared.DataComponent {

	/** returns the selected key */
	String getSelectedKey () {*
		return this.selectedKey;	
	*}
	
	/** sets the selected key */
	void setSelectedKey (String key) {*
		this.selectedKey = key;	
	*}

	/** returns the pressed key */
	String getPressedKey () {*
		return this.pressedKey;	
	*}
}

/**
 * Class for DataTopFlopChart
 */
class org.scn.community.databound.TopFlopChart extends org.scn.community.shared.DataComponent {

	/** returns the selected key */
	String getSelectedKey () {*
		return this.selectedKey;	
	*}
	
	/** sets the selected key */
	void setSelectedKey (String key) {*
		this.selectedKey = key;	
	*}

	/** returns the pressed key */
	String getPressedKey () {*
		return this.pressedKey;	
	*}
}

/**
 * Class for DataDropDown
 */
class org.scn.community.databound.UI5Table extends org.scn.community.shared.DataComponent {
	
	/**
	 * Returns the value of max members property
	 */
	int getMaxMembers() {*
		return this.DMaxMembers;
	*}

	/**
	 * Sets the value of max members property
	 */
	void setMaxMembers(int value) {*
		this.DMaxMembers = value;
	*}
	
	/**
	 * Returns the value of clear others
	 */
	boolean getClearOthers() {*
		return this.DClearOthers;
	*}

	/**
	 * Sets the value of clear others
	 */
	void setClearOthers(boolean value) {*
		this.DClearOthers = value;
	*}
	
	/**
	 * Sets the value of max members property
	 */
	void setCustomDimensions(StringArray value) {*
		this.DCustomDimensions = JSON.stringify(value);
	*}

	/**
	 * DO NOT USE PRIVATE METHODS
	 */
	void private_onSelectionChanged () {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.selection = this.DSelection;
	
		l.selectionJson = JSON.parse(l.selection);
		
		l.dimensionName = l.selectionJson.dimension;
		l.keys = l.selectionJson.keys;
		
		l.keysAsArray = [];

		l.DS = this.getDataSource();
		
		if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		
		if(l.DS) {
			if(l.selectionJson.clearOthers && that.getClearOthers()) {
				this.private_readDimensions(l.DS);
				l.dimensions = this._tempDimensions;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(this, l)};
				
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						l.currentDimensionName = dimension.name
						if(l.currentDimensionName != l.dimensionName) {
							l.DS.clearFilter(l.currentDimensionName);
						}
					}
				});
			}
			
			if(l.keys.length == 1 && l.keys[0] == "-ALL-") {
				l.DS.clearFilter(l.dimensionName);
			} else {
				for (var iK = 0; iK < l.keys.length; iK++) {
					l.key = l.keys[iK];
					
					l.keysAsArray.push(l.key);
				}
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
				
				l.DS.setFilter(l.dimensionName, l.keysAsArray);
			}
		}
		
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
	*}

	/**
	 * 
	 */
	void private_readDimensions (Object dataSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		if(this.DContentMode == "Only from Result Set") {
			l.dimensionsRows = dataSource.getDimensions(Axis.ROWS);
			l.dimensionsColumns = dataSource.getDimensions(Axis.COLUMNS);
			
			l.dimensions = [];

			l.dimensionsRows.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});	
			l.dimensionsColumns.forEach(function(dimension, indexD) {
				l.dimensions.push(dimension);
			});
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		} else if(this.DContentMode == "Custom Dimension Set") {
			l.dimensionsAll = dataSource.getDimensions();
			l.customDimensions = JSON.parse(that.DCustomDimensions);
			
			l.customDimensionsFlat = "|";
			for (var iD = 0; iD < l.customDimensions.length; iD++) {
				l.customDimensionsFlat = l.customDimensionsFlat + l.customDimensions[iD] + "|";
			}
			
			l.dimensions = [];
			
			l.dimensionsAll.forEach(function(dimension, indexD) {
				l.currentAvailableDimensionName = dimension.name; 
				if(l.customDimensionsFlat.indexOf("|" + l.currentAvailableDimensionName + "|") > -1) {
					l.dimensions.push(dimension);
				}
			});	
		} else {
			l.dimensions = dataSource.getDimensions();
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
		
		this._tempDimensions = l.dimensions;
	*}
	
	/**
	 * DO NOT USE PRIVATE METHODS
	 */
	void private_onBeforeRender() {*
	*}
	
	/**
	 * This function must be used for initialization and in case the drilldown structure has been changed.
	 * You should trigger it once and ideally when filters are NOT set on dimensions, other case you will see only members which are available in resultset (depends on your setting "member selection" on dimension level).
	 * When to use this method?
	 * - As soon the Data Source is initialized, either in "onStartup()" script or after loading in script.
	 * <example>
	 * You have loaded the data source and want to initialize.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACETFILTER_1.reloadDataSource();
	 * FACETFILTER_1.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACETFILTER_1.reloadDataSource(DS_FULL);
	 * FACETFILTER_1.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadDataSource(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/

		l.elementsJson = [];

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}

		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensionKeys = "";
			l.dimensions.forEach(function(dimension, index) {
				l.dimensionKeys = l.dimensionKeys + dimension.name;
			});
			
			if(this.oldDimensionKeys != l.dimensionKeys) {
				l.dimensions.forEach(function(dimension, index) {
					if(!dimension.isMeasuresDimension) {
						// warnings to assure query is ok
						if(l.DS.isHierarchyActive(dimension)) {
							APPLICATION.createWarningMessage("Data Source has an Active Hierarchy on Dimension: " + dimension.name);
						}
	
						l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());
	
						l.dimensionJson = {};
						l.dimensionJson.name = dimension.name;
						l.dimensionJson.text = dimension.text;
						l.dimensionJson.isMeasuresDimension = dimension.isMeasuresDimension;
	
						l.dimensionJson.hierarchyActive = l.DS.isHierarchyActive(dimension);
						l.dimensionJson.filterExt = ";" + l.DS.getFilterExt(dimension);
						
						l.dimensionJson.members = l.members;
			
						l.elementsJson.push(l.dimensionJson);
					}
				});

				this.DElements = JSON.stringify(l.elementsJson);
				this.oldDimensionKeys = l.dimensionKeys;
				
				if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			}
		}
		
		/* exiting general block*/
		if(this.isDebug()) {	DEBUG.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}
	
	/**
	 * This function can be used after the filter in data source was changed to update the component.
	 * You should be trigered every time the filter change occurs, therefore the event in Data Source -> onResultSetChanged() is a good place.
	 * When to use this method?
	 * - Always the filter is changed, also the "onResultSetChanged()" event is good for this.
	 * <example>
	 * You want to keep the selections with data source.
	 * The code should be placed in "onResultSetChanged()" method.
	 * <code>
	 * // if you want to update also dimensions when drilldown is changed
	 * FACETFILTER_1.reloadDataSource();
	 * 
	 * // every time 
	 * FACETFILTER_1.reloadSelection();
	 * </code>
	 * </example>
	 * <example>
	 * Especially when you are using option of "Only From Result Set", you can bind a different data source (on the same query) to assure that it stays unfiltered for member selection. This Data Source should be not filtered on any dimension.
	 * The code should be placed in "onStartup()" method.
	 * <code>
	 * FACETFILTER_1.reloadDataSource(DS_FULL);
	 * FACETFILTER_1.reloadSelection(DS_FULL);
	 * </code>
	 * </example>
	 */
	void reloadSelection(/*Data Source which should be used for member selection, in case not the linked Data Source*/optional DataSourceAlias memberAccessSource) {*
		/* entering general block*/
		var that = this;
		var l = {};

		try{
		if(this.isDebug()) {	DEBUG.openZtl(that, l)};
		/* entering general block*/
	
		l.elementsJson = {};

		l.DS = this.getDataSource();

		if(!memberAccessSource) {
			memberAccessSource = l.DS;
		}
		
		if(l.DS) {
			this.private_readDimensions(memberAccessSource);
			l.dimensions = this._tempDimensions;

			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
			
			l.dimensions.forEach(function(dimension, indexD) {
				l.members = memberAccessSource.getMembers(dimension, that.getMaxMembers());

				l.dimensionJson = {};
				l.dimensionJson.name = dimension.name;
				l.dimensionJson.members = [];
				l.dimensionJson.filterExt = "; " + l.DS.getFilterExt(dimension) + ";";

				l.elementsJson[dimension.name] = l.dimensionJson;
			});

			this.DSelection = JSON.stringify(l.elementsJson);
			
			if(this.isDebug()) {	DEBUG.inspectZtl(that, l)};
		}
		
		/* exiting general block*/
		if(this.isDebug("DEBUG_2")) { DEBUG_2.exitZtl(that, l)};
		} catch (e) {
			if(this.isDebug()) {	DEBUG.processZtlException(that, l, e)};throw e;
		}
		/* exiting general block*/
	*}
	
	/**
	 * Sets the sorting direction - ASCENDING | DESCENDING
	 */
	void setSortingDirection (org_scn_community_shared_SortDirectionEnumfield direction) {*
		if(direction == org_scn_community_shared_SortDirection.ASCENDING) {
			this.DSortingType = "Ascending";
			return;
		}
		if(direction == org_scn_community_shared_SortDirection.DESCENDING) {
			this.DSortingType = "Descending";
			return;
		}
		this.DSortingType = "Ascending";
	*}
	
	/**
	 * Sets the sorting type - DEFAULT | ALPHABETICAL | VALUE | SELECTED
	 */
	void setSortingType (org_scn_community_shared_SortTypeEnumfield type) {*
		if(type == org_scn_community_shared_SortType.DEAFULT) {
			this.DSortingType = "Default";
			return;
		}
		if(type == org_scn_community_shared_SortType.VALUE) {
			this.DSortingType = "Value";
			return;
		}
		if(type == org_scn_community_shared_SortType.ALPHABETICAL) {
			this.DSortingType = "Alphabetical";
			return;
		}
		if(type == org_scn_community_shared_SortType.SELECTED) {
			this.DSortingType = "Selected";
			return;
		}
		this.DSortingType = "Default";
	*}
	
	/**
	 * Sets the sorting type - ALL | RESULTSET | CUSTOM
	 */
	void setContentMode (org_scn_community_shared_ContentModeEnumfield mode) {*
		if(mode == org_scn_community_shared_ContentMode.ALL) {
			this.DContentMode = "All Dimensions";
			return;
		}
		if(mode == org_scn_community_shared_ContentMode.RESULTSET) {
			this.DContentMode = "Only from Result Set";
			return;
		}
		if(mode == org_scn_community_shared_ContentMode.CUSTOM) {
			this.DContentMode = "Custom Dimension Set";
			return;
		}
		this.DContentMode = "Only from Result Set";
	*}
	
	void setCustomDimensions (StringArray dimensions) {*
		this.DCustomDimensions = JSON.stringify(dimensions);
	*}
	
	/**
	 * Sets simple selection for dynamic use, you can place here some measure (member of measure dimension)
	 */
	void setSimpleSelection(String dimension, String member) {*
		this.data = "{\""+dimension+"\": \""+member+"\"}";
	*}
}
