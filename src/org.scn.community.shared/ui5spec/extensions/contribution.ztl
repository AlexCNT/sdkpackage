/** GENERATED BY SAPUI5 CONTROLS DEFINITIONS */

/**
 * Generated ZTL Class for BulletChart
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.BulletChart extends org.scn.community.shared.DataComponent {

	/** Adds a root element containing key [String], color [String], value [float].

 	<example>
	You want to add 2 root elements
	<code>
	BULLETCHART.addActual(key [String], color [String], value [float]);<br>
	BULLETCHART.addActual(key [String], color [String], value [float]);<br>
	<br>
	</code>
	</example>
	 */
	void setActual (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
			};

		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			this.actual = "[]";
		}

		var elementsJson = JSON.parse(this.actual);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.actual = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	BULLETCHART.removeActual(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearActual (
			
			) {*

		this.actual = "[]";
	*}

	/**
	 * Updates given Actual<br/>
	 */
	void updateActual (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			this.actual = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
		};

		var elementsJson = JSON.parse(this.actual);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.actual = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getActual (
			
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			this.actual = "[]";
		}

		var elementsJson = JSON.parse(this.actual);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Actuals As JSON String
	 */	
	String getActualsAsJSON() {*
		var jsonObject = JSON.parse(this.actual);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for Actual keys<br/>
	 */
	void setActualColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.actual);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.actual = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Actual Key<br/>
	 */
	void setActualColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.actual);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.actual = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for Actual Key<br/>
	 */
	boolean hasActualColor (
			/**/ String key
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.actual);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/**
	 * Sets Actual Value Label Property
	 */	
	void setActualValueLabel( /**Actual Value Label*/ String actualValueLabel){*
		this.actualValueLabel = actualValueLabel;
	*}

	/**
	 * Gets Actual Value Label Property
	 */	
	String getActualValueLabel() {*
		return this.actualValueLabel;
	*}

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}

	/**
	 * Sets Delta Value Label Property
	 */	
	void setDeltaValueLabel( /**Delta Value Label*/ String deltaValueLabel){*
		this.deltaValueLabel = deltaValueLabel;
	*}

	/**
	 * Gets Delta Value Label Property
	 */	
	String getDeltaValueLabel() {*
		return this.deltaValueLabel;
	*}

	/**
	 * Sets Forecast Value Property
	 */	
	void setForecastValue( /**Forecast Value*/ float forecastValue){*
		this.forecastValue = forecastValue;
	*}

	/**
	 * Gets Forecast Value Property
	 */	
	float getForecastValue() {*
		return this.forecastValue;
	*}

	/**
	 * Sets Max Value Property
	 */	
	void setMaxValue( /**Max Value*/ float maxValue){*
		this.maxValue = maxValue;
	*}

	/**
	 * Gets Max Value Property
	 */	
	float getMaxValue() {*
		return this.maxValue;
	*}

	/**
	 * Sets Min Value Property
	 */	
	void setMinValue( /**Min Value*/ float minValue){*
		this.minValue = minValue;
	*}

	/**
	 * Gets Min Value Property
	 */	
	float getMinValue() {*
		return this.minValue;
	*}

	/**
	 * Sets Mode Property by String
	 */	
	void setModeByString( /**Mode*/ String mode){*
		this.mode = mode;
	*}

	/**
	 * Gets Mode Property as String
	 */	
	String getModeAsString() {*
		return this.mode;
	*}
	
	/**
	 * Sets Mode Property by Choice Option
	 */	
	void setMode( /**Mode*/ org_scn_community_shared_BulletChartModeEnumfield mode){*
		this.mode = mode;
	*}
	
	/**
	 * Gets Mode Property as Choice Option
	 */	
	org_scn_community_shared_BulletChartModeEnumfield getMode() {*
		return this.mode;
	*}

	/**
	 * Sets Scale Property
	 */	
	void setScale( /**Scale*/ String scale){*
		this.scale = scale;
	*}

	/**
	 * Gets Scale Property
	 */	
	String getScale() {*
		return this.scale;
	*}

	/**
	 * Sets Scale Colour Property by String
	 */	
	void setScaleColorByString( /**Scale Colour*/ String scaleColor){*
		this.scaleColor = scaleColor;
	*}

	/**
	 * Gets Scale Colour Property as String
	 */	
	String getScaleColorAsString() {*
		return this.scaleColor;
	*}
	
	/**
	 * Sets Scale Colour Property by Choice Option
	 */	
	void setScaleColor( /**Scale Colour*/ org_scn_community_shared_CommonBackgroundEnumfield scaleColor){*
		this.scaleColor = scaleColor;
	*}
	
	/**
	 * Gets Scale Colour Property as Choice Option
	 */	
	org_scn_community_shared_CommonBackgroundEnumfield getScaleColor() {*
		return this.scaleColor;
	*}

	/**
	 * Sets Show Actual Value Property
	 */	
	void setShowActualValue( /**Show Actual Value*/ boolean showActualValue){*
		this.showActualValue = showActualValue;
	*}

	/**
	 * Gets Show Actual Value Property
	 */	
	boolean isShowActualValue() {*
		return this.showActualValue;
	*}

	/**
	 * Sets Show Delta Value Property
	 */	
	void setShowDeltaValue( /**Show Delta Value*/ boolean showDeltaValue){*
		this.showDeltaValue = showDeltaValue;
	*}

	/**
	 * Gets Show Delta Value Property
	 */	
	boolean isShowDeltaValue() {*
		return this.showDeltaValue;
	*}

	/**
	 * Sets Show Target Value Property
	 */	
	void setShowTargetValue( /**Show Target Value*/ boolean showTargetValue){*
		this.showTargetValue = showTargetValue;
	*}

	/**
	 * Gets Show Target Value Property
	 */	
	boolean isShowTargetValue() {*
		return this.showTargetValue;
	*}

	/**
	 * Sets Show Value Marker Property
	 */	
	void setShowValueMarker( /**Show Value Marker*/ boolean showValueMarker){*
		this.showValueMarker = showValueMarker;
	*}

	/**
	 * Gets Show Value Marker Property
	 */	
	boolean isShowValueMarker() {*
		return this.showValueMarker;
	*}

	/**
	 * Sets Size Property by String
	 */	
	void setSizeByString( /**Size*/ String size){*
		this.size = size;
	*}

	/**
	 * Gets Size Property as String
	 */	
	String getSizeAsString() {*
		return this.size;
	*}
	
	/**
	 * Sets Size Property by Choice Option
	 */	
	void setSize( /**Size*/ org_scn_community_shared_InfoTileSizeEnumfield size){*
		this.size = size;
	*}
	
	/**
	 * Gets Size Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileSizeEnumfield getSize() {*
		return this.size;
	*}

	/**
	 * Sets Target Value Property
	 */	
	void setTargetValue( /**Target Value*/ float targetValue){*
		this.targetValue = targetValue;
	*}

	/**
	 * Gets Target Value Property
	 */	
	float getTargetValue() {*
		return this.targetValue;
	*}

	/**
	 * Sets Target Value Label Property
	 */	
	void setTargetValueLabel( /**Target Value Label*/ String targetValueLabel){*
		this.targetValueLabel = targetValueLabel;
	*}

	/**
	 * Gets Target Value Label Property
	 */	
	String getTargetValueLabel() {*
		return this.targetValueLabel;
	*}

	/** Adds a root element containing key [String], color [String], value [float].

 	<example>
	You want to add 2 root elements
	<code>
	BULLETCHART.addThreshold(key [String], color [String], value [float]);<br>
	BULLETCHART.addThreshold(key [String], color [String], value [float]);<br>
	<br>
	</code>
	</example>
	 */
	void addThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
			};

		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var elementsJson = JSON.parse(this.thresholds);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	BULLETCHART.removeThreshold(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeThreshold (
			String key
			) {*

		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var elementsJson = JSON.parse(this.thresholds);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	BULLETCHART.insertThreshold(index [int], key [String], color [String], value [float]);<br>
	<br>
	</code>
	</example>
	 */
	void insertThreshold (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) {*

		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}
		
		var elementsJson = JSON.parse(this.thresholds);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.thresholds = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Threshold<br/>
	 */
	void updateThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
		};

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getThresholdAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var elementsJson = JSON.parse(this.thresholds);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Thresholds As JSON String
	 */	
	String getThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.thresholds);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for Threshold keys<br/>
	 */
	void setThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.thresholds = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Threshold Key<br/>
	 */
	void setThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for Threshold Key<br/>
	 */
	boolean hasThresholdColor (
			/**/ String key
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.thresholds);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}




	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for BulletChartData
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.BulletChartData extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}

	/**
	 * Sets Value Property
	 */	
	void setValue( /**Value*/ float value){*
		this.value = value;
	*}

	/**
	 * Gets Value Property
	 */	
	float getValue() {*
		return this.value;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for HarveyBallMicroChart
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.HarveyBallMicroChart extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Palette Property as StringArray
	 */	
	void setColorPalette( /**Colour Palette*/ StringArray colorPalette){*
		this.colorPalette = colorPalette;
	*}
	
	/** Gets Colour Palette Property as StringArray

 	<example>
	You want to ask for the current property value
	<code>
	HARVEYBALLMICROCHART.getColorPalette();<br>
	</code>
	</example>
	 */
	StringArray getColorPalette () {*		
		var elementsJson = JSON.parse(this.colorPalette);
		return elementsJson;
	*}

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}

	/**
	 * Sets Formatted Label Property
	 */	
	void setFormattedLabel( /**Formatted Label*/ boolean formattedLabel){*
		this.formattedLabel = formattedLabel;
	*}

	/**
	 * Gets Formatted Label Property
	 */	
	boolean isFormattedLabel() {*
		return this.formattedLabel;
	*}

	/** Adds a root element containing key [String], color [String], formattedLabel [boolean], fraction [float], fractionLabel [String], fractionScale [String].

 	<example>
	You want to add 2 root elements
	<code>
	HARVEYBALLMICROCHART.addItem(key [String], color [String], formattedLabel [boolean], fraction [float], fractionLabel [String], fractionScale [String]);<br>
	HARVEYBALLMICROCHART.addItem(key [String], color [String], formattedLabel [boolean], fraction [float], fractionLabel [String], fractionScale [String]);<br>
	<br>
	</code>
	</example>
	 */
	void addItem (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Formatted Label*/boolean formattedLabel, 
			/**Fraction*/float fraction, 
			/**Fraction Label*/String fractionLabel, 
			/**Fraction Scale*/String fractionScale
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			formattedLabel:formattedLabel, 
			fraction:fraction, 
			fractionLabel:fractionLabel, 
			fractionScale:fractionScale
			};

		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var elementsJson = JSON.parse(this.items);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	HARVEYBALLMICROCHART.removeItem(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeItem (
			String key
			) {*

		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var elementsJson = JSON.parse(this.items);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	HARVEYBALLMICROCHART.insertItem(index [int], key [String], color [String], formattedLabel [boolean], fraction [float], fractionLabel [String], fractionScale [String]);<br>
	<br>
	</code>
	</example>
	 */
	void insertItem (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Formatted Label*/boolean formattedLabel, 
			/**Fraction*/float fraction, 
			/**Fraction Label*/String fractionLabel, 
			/**Fraction Scale*/String fractionScale
			) {*

		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}
		
		var elementsJson = JSON.parse(this.items);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			formattedLabel:formattedLabel, 
			fraction:fraction, 
			fractionLabel:fractionLabel, 
			fractionScale:fractionScale
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.items = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Item<br/>
	 */
	void updateItem (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Formatted Label*/boolean formattedLabel, 
			/**Fraction*/float fraction, 
			/**Fraction Label*/String fractionLabel, 
			/**Fraction Scale*/String fractionScale
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			formattedLabel:formattedLabel, 
			fraction:fraction, 
			fractionLabel:fractionLabel, 
			fractionScale:fractionScale
		};

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getItemAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			this.items = "[]";
		}

		var elementsJson = JSON.parse(this.items);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Items As JSON String
	 */	
	String getItemsAsJSON() {*
		var jsonObject = JSON.parse(this.items);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for Item keys<br/>
	 */
	void setItemColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Item Key<br/>
	 */
	void setItemColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for Item Key<br/>
	 */
	boolean hasItemColor (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the FormattedLabel for Item keys<br/>
	 */
	void setItemFormattedLabels (
			/**/ String keys,
			/**/ String separator
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].formattedLabel = false;
			
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].formattedLabel = true;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the FormattedLabel for Item Key<br/>
	 */
	void setItemFormattedLabel (
			/**/ String key,
			/**/ boolean formattedLabel
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].formattedLabel = formattedLabel;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}

		
	/**
	 * Clean all FormattedLabel of Item keys<br/>
	 */
	void cleanAllItemFormattedLabels (
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			// clean all
			elementsJson[i].formattedLabel = false;
		}
		
		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of FormattedLabel for Item Key<br/>
	 */
	boolean hasItemFormattedLabel (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}

	/**
	 * Returns the FormattedLabel keys<br/>
	 */
	org.scn.pack.KeyArray getItemFormattedLabelKeysArray (
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return [];
		}
		
		var elementsJson = JSON.parse(this.items);
		
		var newElementsJson = [];
		
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].formattedLabel == true) {
				newElementsJson.push(elementsJson[i]);
			}
		}
		
		return newElementsJson;
	*}
	/**
	 * Sets the FractionLabel for Item keys<br/>
	 */
	void setItemFractionLabels (
			/**/ String keys,
			/**/ String separator,
	        /* FractionLabel */ String fractionLabel
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].fractionLabel = fractionLabel;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the FractionLabel for Item Key<br/>
	 */
	void setItemFractionLabel (
			/**/ String key,
			/**/ String fractionLabel
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].fractionLabel = fractionLabel;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of FractionLabel for Item Key<br/>
	 */
	boolean hasItemFractionLabel (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the FractionScale for Item keys<br/>
	 */
	void setItemFractionScales (
			/**/ String keys,
			/**/ String separator,
	        /* FractionScale */ String fractionScale
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.items);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].fractionScale = fractionScale;
					break;
				}
			}
		}
		
		this.items = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the FractionScale for Item Key<br/>
	 */
	void setItemFractionScale (
			/**/ String key,
			/**/ String fractionScale
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].fractionScale = fractionScale;
				break;
			}
		}

		this.items = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of FractionScale for Item Key<br/>
	 */
	boolean hasItemFractionScale (
			/**/ String key
			) 
	{*
		if (this.items === undefined || this.items === "" || this.items === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.items);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/**
	 * Sets Show Fractions Property
	 */	
	void setShowFractions( /**Show Fractions*/ boolean showFractions){*
		this.showFractions = showFractions;
	*}

	/**
	 * Gets Show Fractions Property
	 */	
	boolean isShowFractions() {*
		return this.showFractions;
	*}

	/**
	 * Sets Show Total Property
	 */	
	void setShowTotal( /**Show Total*/ boolean showTotal){*
		this.showTotal = showTotal;
	*}

	/**
	 * Gets Show Total Property
	 */	
	boolean isShowTotal() {*
		return this.showTotal;
	*}

	/**
	 * Sets Size Property by String
	 */	
	void setSizeByString( /**Size*/ String size){*
		this.size = size;
	*}

	/**
	 * Gets Size Property as String
	 */	
	String getSizeAsString() {*
		return this.size;
	*}
	
	/**
	 * Sets Size Property by Choice Option
	 */	
	void setSize( /**Size*/ org_scn_community_shared_InfoTileSizeEnumfield size){*
		this.size = size;
	*}
	
	/**
	 * Gets Size Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileSizeEnumfield getSize() {*
		return this.size;
	*}

	/**
	 * Sets Total Property
	 */	
	void setTotal( /**Total*/ float total){*
		this.total = total;
	*}

	/**
	 * Gets Total Property
	 */	
	float getTotal() {*
		return this.total;
	*}

	/**
	 * Sets Total Label Property
	 */	
	void setTotalLabel( /**Total Label*/ String totalLabel){*
		this.totalLabel = totalLabel;
	*}

	/**
	 * Gets Total Label Property
	 */	
	String getTotalLabel() {*
		return this.totalLabel;
	*}

	/**
	 * Sets Total Scale Property
	 */	
	void setTotalScale( /**Total Scale*/ String totalScale){*
		this.totalScale = totalScale;
	*}

	/**
	 * Gets Total Scale Property
	 */	
	String getTotalScale() {*
		return this.totalScale;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for HarveyBallMicroChartItem
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.HarveyBallMicroChartItem extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}

	/**
	 * Sets Formatted Label Property
	 */	
	void setFormattedLabel( /**Formatted Label*/ boolean formattedLabel){*
		this.formattedLabel = formattedLabel;
	*}

	/**
	 * Gets Formatted Label Property
	 */	
	boolean isFormattedLabel() {*
		return this.formattedLabel;
	*}

	/**
	 * Sets Fraction Property
	 */	
	void setFraction( /**Fraction*/ float fraction){*
		this.fraction = fraction;
	*}

	/**
	 * Gets Fraction Property
	 */	
	float getFraction() {*
		return this.fraction;
	*}

	/**
	 * Sets Fraction Label Property
	 */	
	void setFractionLabel( /**Fraction Label*/ String fractionLabel){*
		this.fractionLabel = fractionLabel;
	*}

	/**
	 * Gets Fraction Label Property
	 */	
	String getFractionLabel() {*
		return this.fractionLabel;
	*}

	/**
	 * Sets Fraction Scale Property
	 */	
	void setFractionScale( /**Fraction Scale*/ String fractionScale){*
		this.fractionScale = fractionScale;
	*}

	/**
	 * Gets Fraction Scale Property
	 */	
	String getFractionScale() {*
		return this.fractionScale;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChart
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChart extends org.scn.community.shared.DataComponent {

	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			this.chart = "[]";
		}
		
		var elementsJson = JSON.parse(this.chart);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.chart = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setChart(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setChart (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			this.chart = "[]";
		}
		
		var elementsJson = JSON.parse(this.chart);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.chart = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			this.chart = "[]";
		}
		
		var elementsJson = JSON.parse(this.chart);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.chart = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearChart();<br>
	<br>
	</code>
	</example>
	 */
	void clearChart (
			
			) {*		
		
		this.chart = "[]";
	*}

	/**
	 * Gets Charts As JSON String
	 */	
	String getChartsAsJSON() {*
		var jsonObject = JSON.parse(this.chart);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for Chart keys<br/>
	 */
	void setChartColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.chart);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.chart = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Chart Key<br/>
	 */
	void setChartColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.chart);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.chart = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for Chart Key<br/>
	 */
	boolean hasChartColor (
			/**/ String key
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.chart);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/**
	 * Sets Content Height Property
	 */	
	void setContentHeight( /**Content Height*/ int contentHeight){*
		this.contentHeight = contentHeight;
	*}

	/**
	 * Gets Content Height Property
	 */	
	int getContentHeight() {*
		return this.contentHeight;
	*}

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}

	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addFirstXLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addFirstXLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setFirstXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			this.firstXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeFirstXLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearFirstXLabel (
			
			) {*

		this.firstXLabel = "[]";
	*}

	/**
	 * Updates given FirstXLabel<br/>
	 */
	void updateFirstXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			this.firstXLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getFirstXLabel (
			
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			this.firstXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets FirstXLabels As JSON String
	 */	
	String getFirstXLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.firstXLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for FirstXLabel keys<br/>
	 */
	void setFirstXLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.firstXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for FirstXLabel Key<br/>
	 */
	void setFirstXLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for FirstXLabel Key<br/>
	 */
	boolean hasFirstXLabelColor (
			/**/ String key
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for FirstXLabel keys<br/>
	 */
	void setFirstXLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.firstXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for FirstXLabel Key<br/>
	 */
	void setFirstXLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for FirstXLabel Key<br/>
	 */
	boolean hasFirstXLabelLabel (
			/**/ String key
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addFirstYLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addFirstYLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setFirstYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			this.firstYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeFirstYLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearFirstYLabel (
			
			) {*

		this.firstYLabel = "[]";
	*}

	/**
	 * Updates given FirstYLabel<br/>
	 */
	void updateFirstYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			this.firstYLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getFirstYLabel (
			
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			this.firstYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets FirstYLabels As JSON String
	 */	
	String getFirstYLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.firstYLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for FirstYLabel keys<br/>
	 */
	void setFirstYLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.firstYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for FirstYLabel Key<br/>
	 */
	void setFirstYLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for FirstYLabel Key<br/>
	 */
	boolean hasFirstYLabelColor (
			/**/ String key
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for FirstYLabel keys<br/>
	 */
	void setFirstYLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.firstYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for FirstYLabel Key<br/>
	 */
	void setFirstYLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for FirstYLabel Key<br/>
	 */
	boolean hasFirstYLabelLabel (
			/**/ String key
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			this.innerMaxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMaxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setInnerMaxThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setInnerMaxThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			this.innerMaxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			this.innerMaxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMaxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearInnerMaxThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearInnerMaxThreshold (
			
			) {*		
		
		this.innerMaxThreshold = "[]";
	*}

	/**
	 * Gets InnerMaxThresholds As JSON String
	 */	
	String getInnerMaxThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.innerMaxThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for InnerMaxThreshold keys<br/>
	 */
	void setInnerMaxThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for InnerMaxThreshold Key<br/>
	 */
	void setInnerMaxThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for InnerMaxThreshold Key<br/>
	 */
	boolean hasInnerMaxThresholdColor (
			/**/ String key
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			this.innerMinThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMinThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setInnerMinThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setInnerMinThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			this.innerMinThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMinThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			this.innerMinThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMinThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearInnerMinThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearInnerMinThreshold (
			
			) {*		
		
		this.innerMinThreshold = "[]";
	*}

	/**
	 * Gets InnerMinThresholds As JSON String
	 */	
	String getInnerMinThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.innerMinThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for InnerMinThreshold keys<br/>
	 */
	void setInnerMinThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.innerMinThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for InnerMinThreshold Key<br/>
	 */
	void setInnerMinThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMinThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for InnerMinThreshold Key<br/>
	 */
	boolean hasInnerMinThresholdColor (
			/**/ String key
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMinThreshold);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addLastXLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addLastXLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setLastXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			this.lastXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeLastXLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearLastXLabel (
			
			) {*

		this.lastXLabel = "[]";
	*}

	/**
	 * Updates given LastXLabel<br/>
	 */
	void updateLastXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			this.lastXLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getLastXLabel (
			
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			this.lastXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets LastXLabels As JSON String
	 */	
	String getLastXLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.lastXLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for LastXLabel keys<br/>
	 */
	void setLastXLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.lastXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for LastXLabel Key<br/>
	 */
	void setLastXLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for LastXLabel Key<br/>
	 */
	boolean hasLastXLabelColor (
			/**/ String key
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for LastXLabel keys<br/>
	 */
	void setLastXLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.lastXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for LastXLabel Key<br/>
	 */
	void setLastXLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for LastXLabel Key<br/>
	 */
	boolean hasLastXLabelLabel (
			/**/ String key
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addLastYLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addLastYLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setLastYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			this.lastYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeLastYLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearLastYLabel (
			
			) {*

		this.lastYLabel = "[]";
	*}

	/**
	 * Updates given LastYLabel<br/>
	 */
	void updateLastYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			this.lastYLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getLastYLabel (
			
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			this.lastYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets LastYLabels As JSON String
	 */	
	String getLastYLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.lastYLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for LastYLabel keys<br/>
	 */
	void setLastYLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.lastYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for LastYLabel Key<br/>
	 */
	void setLastYLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for LastYLabel Key<br/>
	 */
	boolean hasLastYLabelColor (
			/**/ String key
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for LastYLabel keys<br/>
	 */
	void setLastYLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.lastYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for LastYLabel Key<br/>
	 */
	void setLastYLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for LastYLabel Key<br/>
	 */
	boolean hasLastYLabelLabel (
			/**/ String key
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addMaxLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addMaxLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setMaxLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			this.maxLabel = "[]";
		}

		var elementsJson = JSON.parse(this.maxLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeMaxLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearMaxLabel (
			
			) {*

		this.maxLabel = "[]";
	*}

	/**
	 * Updates given MaxLabel<br/>
	 */
	void updateMaxLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			this.maxLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getMaxLabel (
			
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			this.maxLabel = "[]";
		}

		var elementsJson = JSON.parse(this.maxLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets MaxLabels As JSON String
	 */	
	String getMaxLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.maxLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for MaxLabel keys<br/>
	 */
	void setMaxLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.maxLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MaxLabel Key<br/>
	 */
	void setMaxLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for MaxLabel Key<br/>
	 */
	boolean hasMaxLabelColor (
			/**/ String key
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for MaxLabel keys<br/>
	 */
	void setMaxLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.maxLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for MaxLabel Key<br/>
	 */
	void setMaxLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for MaxLabel Key<br/>
	 */
	boolean hasMaxLabelLabel (
			/**/ String key
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			this.maxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.maxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.maxThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setMaxThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setMaxThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			this.maxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.maxThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			this.maxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.maxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearMaxThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearMaxThreshold (
			
			) {*		
		
		this.maxThreshold = "[]";
	*}

	/**
	 * Gets MaxThresholds As JSON String
	 */	
	String getMaxThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.maxThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for MaxThreshold keys<br/>
	 */
	void setMaxThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MaxThreshold Key<br/>
	 */
	void setMaxThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.maxThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for MaxThreshold Key<br/>
	 */
	boolean hasMaxThresholdColor (
			/**/ String key
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxThreshold);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/**
	 * Sets Max X Value Property
	 */	
	void setMaxXValue( /**Max X Value*/ float maxXValue){*
		this.maxXValue = maxXValue;
	*}

	/**
	 * Gets Max X Value Property
	 */	
	float getMaxXValue() {*
		return this.maxXValue;
	*}

	/**
	 * Sets Max Y Value Property
	 */	
	void setMaxYValue( /**Max Y Value*/ float maxYValue){*
		this.maxYValue = maxYValue;
	*}

	/**
	 * Gets Max Y Value Property
	 */	
	float getMaxYValue() {*
		return this.maxYValue;
	*}

	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addMinLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addMinLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setMinLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			this.minLabel = "[]";
		}

		var elementsJson = JSON.parse(this.minLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeMinLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearMinLabel (
			
			) {*

		this.minLabel = "[]";
	*}

	/**
	 * Updates given MinLabel<br/>
	 */
	void updateMinLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			this.minLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getMinLabel (
			
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			this.minLabel = "[]";
		}

		var elementsJson = JSON.parse(this.minLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets MinLabels As JSON String
	 */	
	String getMinLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.minLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for MinLabel keys<br/>
	 */
	void setMinLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.minLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MinLabel Key<br/>
	 */
	void setMinLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for MinLabel Key<br/>
	 */
	boolean hasMinLabelColor (
			/**/ String key
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for MinLabel keys<br/>
	 */
	void setMinLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.minLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for MinLabel Key<br/>
	 */
	void setMinLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for MinLabel Key<br/>
	 */
	boolean hasMinLabelLabel (
			/**/ String key
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			this.minThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.minThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.minThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setMinThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setMinThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			this.minThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.minThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			this.minThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.minThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearMinThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearMinThreshold (
			
			) {*		
		
		this.minThreshold = "[]";
	*}

	/**
	 * Gets MinThresholds As JSON String
	 */	
	String getMinThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.minThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for MinThreshold keys<br/>
	 */
	void setMinThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MinThreshold Key<br/>
	 */
	void setMinThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.minThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for MinThreshold Key<br/>
	 */
	boolean hasMinThresholdColor (
			/**/ String key
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minThreshold);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/**
	 * Sets Min X Value Property
	 */	
	void setMinXValue( /**Min X Value*/ float minXValue){*
		this.minXValue = minXValue;
	*}

	/**
	 * Gets Min X Value Property
	 */	
	float getMinXValue() {*
		return this.minXValue;
	*}

	/**
	 * Sets Min Y Value Property
	 */	
	void setMinYValue( /**Min Y Value*/ float minYValue){*
		this.minYValue = minYValue;
	*}

	/**
	 * Gets Min Y Value Property
	 */	
	float getMinYValue() {*
		return this.minYValue;
	*}

	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			this.target = "[]";
		}
		
		var elementsJson = JSON.parse(this.target);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.target = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setTarget(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setTarget (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			this.target = "[]";
		}
		
		var elementsJson = JSON.parse(this.target);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.target = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			this.target = "[]";
		}
		
		var elementsJson = JSON.parse(this.target);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.target = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearTarget();<br>
	<br>
	</code>
	</example>
	 */
	void clearTarget (
			
			) {*		
		
		this.target = "[]";
	*}

	/**
	 * Gets Targets As JSON String
	 */	
	String getTargetsAsJSON() {*
		var jsonObject = JSON.parse(this.target);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for Target keys<br/>
	 */
	void setTargetColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.target);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.target = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Target Key<br/>
	 */
	void setTargetColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.target);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.target = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for Target Key<br/>
	 */
	boolean hasTargetColor (
			/**/ String key
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.target);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/**
	 * Sets View Property by String
	 */	
	void setViewByString( /**View*/ String view){*
		this.view = view;
	*}

	/**
	 * Gets View Property as String
	 */	
	String getViewAsString() {*
		return this.view;
	*}
	
	/**
	 * Sets View Property by Choice Option
	 */	
	void setView( /**View*/ org_scn_community_shared_MicroAreaChartViewEnumfield view){*
		this.view = view;
	*}
	
	/**
	 * Gets View Property as Choice Option
	 */	
	org_scn_community_shared_MicroAreaChartViewEnumfield getView() {*
		return this.view;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChartItem
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChartItem extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}

	/** Adds a root element containing key [String], x [float], y [float].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHARTITEM.addPoint(key [String], x [float], y [float]);<br>
	MICROAREACHARTITEM.addPoint(key [String], x [float], y [float]);<br>
	<br>
	</code>
	</example>
	 */
	void addPoint (
			/**Unique Property Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			x:x, 
			y:y
			};

		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var elementsJson = JSON.parse(this.points);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.points = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHARTITEM.removePoint(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removePoint (
			String key
			) {*

		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var elementsJson = JSON.parse(this.points);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.points = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	MICROAREACHARTITEM.insertPoint(index [int], key [String], x [float], y [float]);<br>
	<br>
	</code>
	</example>
	 */
	void insertPoint (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*

		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}
		
		var elementsJson = JSON.parse(this.points);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			x:x, 
			y:y
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.points = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Point<br/>
	 */
	void updatePoint (
			/**Unique Property Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			x:x, 
			y:y
		};

		var elementsJson = JSON.parse(this.points);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.points = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getPointAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var elementsJson = JSON.parse(this.points);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Points As JSON String
	 */	
	String getPointsAsJSON() {*
		var jsonObject = JSON.parse(this.points);
		return JSON.stringify(jsonObject, null, 4);
	*}
	




	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChartLabel
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChartLabel extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}

	/**
	 * Sets Label Property
	 */	
	void setLabel( /**Label*/ String label){*
		this.label = label;
	*}

	/**
	 * Gets Label Property
	 */	
	String getLabel() {*
		return this.label;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChartPoint
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChartPoint extends org.scn.community.shared.DataComponent {

	/**
	 * Sets X Property
	 */	
	void setX( /**X*/ float x){*
		this.x = x;
	*}

	/**
	 * Gets X Property
	 */	
	float getX() {*
		return this.x;
	*}

	/**
	 * Sets Y Property
	 */	
	void setY( /**Y*/ float y){*
		this.y = y;
	*}

	/**
	 * Gets Y Property
	 */	
	float getY() {*
		return this.y;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}
