/* GENERATED - DO NOT EDIT */
/**
 * Copyright 2014, Contributors
 * 
 * Original Source Code Location:
 *  https://github.com/org-scn-design-studio-community/sdkpackage/
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */


/**
	Array Holder for Component, Name and Type
 */
class org.scn.community.shared.ComponentHolder {
	  Component component;
	  String name;
	  String type;
}

/**
	Array for Components
	<br>
	var panels = COMPONENTHOLDER.getPanels();<br>
	<br>
	// a loop for all entries<br>
	// content is of type Component<br>
	panels.forEach(function(element, index) {<br>
	
		// panel is of type Component<br>
		var componentWidth = element.getWidth();<br>
	});
 */
class org.scn.community.shared.ComponentArray extends Array {
	org.scn.community.shared.ComponentArray (org.scn.community.shared.ComponentHolder h);
}


/**
	Array Holder for DataSourceAlias, Name and Type
 */
class org.scn.community.shared.DataSourceHolder {
	  DataSourceAlias datasource;
	  String name;
	  String type;
}

/**
	Array for DataSourceAlias
	<br>
	var panels = COMPONENTHOLDER.getPanels();<br>
	<br>
	// a loop for all entries<br>
	// content is of type DataSourceAlias<br>
	panels.forEach(function(element, index) {<br>
	
		// panel is of type DataSourceAlias<br>
		var componentWidth = element.getWidth();<br>
	});
 */
class org.scn.community.shared.DataSourceArray extends Array {
	org.scn.community.shared.DataSourceArray (org.scn.community.shared.DataSourceHolder h);
}

/**
 * enum filed definition
 */
class org_scn_community_shared_BrowserEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_Browser extends Enum {

	/** DEFAULT */
	org_scn_community_shared_BrowserEnumfield CHROME;
       
	/** EMPH */
	org_scn_community_shared_BrowserEnumfield SAFARI;

	/** ACCEPT */
	org_scn_community_shared_BrowserEnumfield MOZILLA;

	/** REJECT */
	org_scn_community_shared_BrowserEnumfield IE;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_ButtonStyleEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_ButtonStyle extends Enum {

	/** DEFAULT */
	org_scn_community_shared_ButtonStyleEnumfield Default;
       
	/** EMPH */
	org_scn_community_shared_ButtonStyleEnumfield Emph;

	/** ACCEPT */
	org_scn_community_shared_ButtonStyleEnumfield Accept;

	/** REJECT */
	org_scn_community_shared_ButtonStyleEnumfield Reject;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_ButtonTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_ButtonType extends Enum {

	/** Default */
	org_scn_community_shared_ButtonTypeEnumfield Default;
       
	/** Transparent */
	org_scn_community_shared_ButtonTypeEnumfield Transparent;

	/** Accept */
	org_scn_community_shared_ButtonTypeEnumfield Accept;

	/** Reject */
	org_scn_community_shared_ButtonTypeEnumfield Reject;
	
	/** Back */
	org_scn_community_shared_ButtonTypeEnumfield Back;
	
	/** Emphasized */
	org_scn_community_shared_ButtonTypeEnumfield Emphasized;
	
	/** Up */
	org_scn_community_shared_ButtonTypeEnumfield Up;
}
/**
 * enum filed definition
 */
class org_scn_community_shared_ContentNotationEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_ContentNotation extends Enum {

	/** PARENT_CHILD_TEXT_URL, for components which are supporting this notation */
	org_scn_community_shared_ContentNotationEnumfield PARENT_CHILD_TEXT_URL;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_DateViewTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_DateViewType extends Enum {

	/** Day */
	org_scn_community_shared_DateViewTypeEnumfield Day;
       
	/** Week */
	org_scn_community_shared_DateViewTypeEnumfield Week;

	/** Month */
	org_scn_community_shared_DateViewTypeEnumfield Month;

	/** Year */
	org_scn_community_shared_DateViewTypeEnumfield Year;

	/** Custom_Week */
	org_scn_community_shared_DateViewTypeEnumfield Custom_Week;

	/** Custom_Duration */
	org_scn_community_shared_DateViewTypeEnumfield Custom_Duration;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_DimensionSetEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_DimensionSet extends Enum {

	/** ALL_DIMENSIONS */
	org_scn_community_shared_DimensionSetEnumfield All;
       
	/** RESULT_SET_DIMENSIONS */
	org_scn_community_shared_DimensionSetEnumfield Resultset;

	/** CUSTOM_DIMENSIONS */
	org_scn_community_shared_DimensionSetEnumfield Custom;
}
/**
 * enum filed definition
 */
class org_scn_community_shared_DecimalPlacesEnumfield extends Enumfield {
       
}

/**
 * a set of constants definition 
 */
class org_scn_community_shared_DecimalPlaces extends Enum {

	/** 0 */
	org_scn_community_shared_DecimalPlacesEnumfield D0;
       
	/** 1 */
	org_scn_community_shared_DecimalPlacesEnumfield D1;

	/** 2 */
	org_scn_community_shared_DecimalPlacesEnumfield D2;

	/** 3 */
	org_scn_community_shared_DecimalPlacesEnumfield D3;

	/** 4 */
	org_scn_community_shared_DecimalPlacesEnumfield D4;

	/** 5 */
	org_scn_community_shared_DecimalPlacesEnumfield D5;

	/** 6 */
	org_scn_community_shared_DecimalPlacesEnumfield D6;

	/** 7 */
	org_scn_community_shared_DecimalPlacesEnumfield D7;

	/** 8 */
	org_scn_community_shared_DecimalPlacesEnumfield D8;

	/** 9 */
	org_scn_community_shared_DecimalPlacesEnumfield D9;

}

/**
 * enum filed definition
 */
class org_scn_community_shared_FormatStyleEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_FormatStyle extends Enum {

	/** Short */
	org_scn_community_shared_FormatStyleEnumfield Short;
       
	/** Medium */
	org_scn_community_shared_FormatStyleEnumfield Medium;

	/** Long */
	org_scn_community_shared_FormatStyleEnumfield Long;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_FormattingOperatorEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_FormattingOperator extends Enum {

	/** Use_First */
	org_scn_community_shared_FormattingOperatorEnumfield Use_First;
       
	/** Use_Last */
	org_scn_community_shared_FormattingOperatorEnumfield Use_Last;

	/** Collect */
	org_scn_community_shared_FormattingOperatorEnumfield Collect;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_HorizontalAlignEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_HorizontalAlign extends Enum {

	/** Left */
	org_scn_community_shared_HorizontalAlignEnumfield Left;
       
	/** Right */
	org_scn_community_shared_HorizontalAlignEnumfield Right;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_ImageSizeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_ImageSize extends Enum {

	/** 16x16 pixels */
	org_scn_community_shared_ImageSizeEnumfield Size_16px;

	/** 32x32 pixels */
	org_scn_community_shared_ImageSizeEnumfield Size_32px;

	/** 64x64 pixels */
	org_scn_community_shared_ImageSizeEnumfield Size_64px;
	
	/** 128x128 pixels */
	org_scn_community_shared_ImageSizeEnumfield Size_128px;
}
/**
 * enum filed definition
 */
class org_scn_community_shared_MemberDisplayEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_MemberDisplay extends Enum {

	/** Text */
	org_scn_community_shared_MemberDisplayEnumfield Text;
       
	/** Text Value */
	org_scn_community_shared_MemberDisplayEnumfield Text_Value;

	/** Text Key*/
	org_scn_community_shared_MemberDisplayEnumfield Text_Key;

	/** Text Count*/
	org_scn_community_shared_MemberDisplayEnumfield Text_Count;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_NavigationTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_NavigationType extends Enum {

	/** PAGINATOR */
	org_scn_community_shared_NavigationTypeEnumfield Paginator;
       
	/** SCROLLBAR */
	org_scn_community_shared_NavigationTypeEnumfield Scrollbar;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_PlacementTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_PlacementType extends Enum {

	/** Auto */
	org_scn_community_shared_PlacementTypeEnumfield Auto;
       
	/** Horizontal */
	org_scn_community_shared_PlacementTypeEnumfield Horizontal;

	/** Vertical */
	org_scn_community_shared_PlacementTypeEnumfield Vertical;

	/** Left */
	org_scn_community_shared_PlacementTypeEnumfield Left;
	
	/** Right */
	org_scn_community_shared_PlacementTypeEnumfield Right;
	
	/** Top */
	org_scn_community_shared_PlacementTypeEnumfield Top;
	
	/** Bottom */
	org_scn_community_shared_PlacementTypeEnumfield Bottom;
}
/**
 * enum filed definition
 */
class org_scn_community_shared_SelectionStateEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_SelectionState extends Enum {

	/** Checked */
	org_scn_community_shared_SelectionStateEnumfield Checked;
       
	/** Unchecked */
	org_scn_community_shared_SelectionStateEnumfield Unchecked;

	/** Mixed */
	org_scn_community_shared_SelectionStateEnumfield Mixed;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_SelectionTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_SelectionType extends Enum {

	/** Single */
	org_scn_community_shared_SelectionTypeEnumfield Single;
       
	/** Range */
	org_scn_community_shared_SelectionTypeEnumfield Range;

	/** Multiple */
	org_scn_community_shared_SelectionTypeEnumfield Multiple;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_SecondValueContentEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify field 
 */
class org_scn_community_shared_SecondValueContent extends Enum {

	/** Value */
	org_scn_community_shared_SecondValueContentEnumfield Value;
       
	/** Key */
	org_scn_community_shared_SecondValueContentEnumfield Key;

	/** Count */
	org_scn_community_shared_SecondValueContentEnumfield Count;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_SortDirectionEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort direction 
 */
class org_scn_community_shared_SortDirection extends Enum {

	/** ASCENDING */
	org_scn_community_shared_SortDirectionEnumfield Ascending;
       
	/** DESCENDING */
	org_scn_community_shared_SortDirectionEnumfield Descending;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_SelectionTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_SelectionType extends Enum {

	/** Single */
	org_scn_community_shared_SelectionTypeEnumfield Single;
       
	/** Range */
	org_scn_community_shared_SelectionTypeEnumfield Range;

	/** Multiple */
	org_scn_community_shared_SelectionTypeEnumfield Multiple;
}

/**
 * enum filed definition
 */
class org_scn_community_shared_SortTypeEnumfield extends Enumfield {
       
}

/**
 * a set of constants to specify sort type 
 */
class org_scn_community_shared_SortType extends Enum {

	/** Default */
	org_scn_community_shared_SortTypeEnumfield Default;
       
	/** Alphabetical */
	org_scn_community_shared_SortTypeEnumfield Alphabetical;

	/** Count */
	org_scn_community_shared_SortTypeEnumfield Count;
	
	/** Selected */
	org_scn_community_shared_SortTypeEnumfield Selected;

	/** Value */
	org_scn_community_shared_SortTypeEnumfield Value;
}

/**
	Holder for Dimension, Member. You can access the content as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.DimensionMemberArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.DimensionMember<br>
		var elDimension = element.dimension;<br>
		var elMember = element.member;<br>
	});
 */
class org.scn.community.shared.DimensionMember {
  String dimension;
  String member;
}

/**
	Array for org.scn.community.shared.DimensionMember. You can use this array as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.DimensionMemberArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.DimensionMemberValue<br>
		var elDimension = element.dimension;<br>
		var elMember = element.member;<br>
	});
 */
class org.scn.community.shared.DimensionMemberArray extends Array {
	org.scn.community.shared.DimensionMemberArray (org.scn.community.shared.DimensionMember b);
}

/**
	Holder for Key, Text. You can access the content as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.Key<br>
		var elKey = element.key;<br>
	});
 */
class org.scn.community.shared.Key {
  String key;
}

/**
	Array for org.scn.community.shared.KeyText. You can use this array as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyValue<br>
		var elKey = element.key;<br>
	});
 */
class org.scn.community.shared.KeyArray extends Array {
	org.scn.community.shared.KeyArray (org.scn.community.shared.Key b);
}

/**
	Holder for Key, Label. You can access the content as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyLabelArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyLabel<br>
		var elKey = element.key;<br>
		var elLabel = element.label;<br>
	});
 */
class org.scn.community.shared.KeyLabel {
  String key;
  String label;
}

/**
	Array for org.scn.community.shared.KeyLabel. You can use this array as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyLabelArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyLabelValue<br>
		var elKey = element.key;<br>
		var elLabel = element.label;<br>
	});
 */
class org.scn.community.shared.KeyLabelArray extends Array {
	org.scn.community.shared.KeyLabelArray (org.scn.community.shared.KeyLabel b);
}

/**
	Holder for Key, Text. You can access the content as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyTextArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyText<br>
		var elKey = element.key;<br>
		var elText = element.text;<br>
	});
 */
class org.scn.community.shared.KeyText {
  String key;
  String text;
}

/**
	Array for org.scn.community.shared.KeyText. You can use this array as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyTextArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyTextValue<br>
		var elKey = element.key;<br>
		var elText = element.text;<br>
	});
 */
class org.scn.community.shared.KeyTextArray extends Array {
	org.scn.community.shared.KeyTextArray (org.scn.community.shared.KeyText b);
}

/**
	Holder for Key, Label, Value. You can access the content as in below example.
	<br>
	var content = COLLECTION_1.getAsKeyLabelValueArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyLabelValueArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyLabelValue<br>
		var elKey = element.key;<br>
		var elLabel = element.label;<br>
	 	var elValue = "( " + element.value + " )");<br>
	});
 */
class org.scn.community.shared.KeyLabelValue {
  String key;
  String label;
  float value;
}

/**
	Array for org.scn.community.shared.KeyLabelValue. You can use this array as in below example.
	<br>
	var content = COLLECTION_1.getAsKeyLabelValueArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyLabelValueArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyLabelValue<br>
		var elKey = element.key;<br>
		var elLabel = element.label;<br>
	 	var elValue = "( " + element.value + " )");<br>
	});
 */
class org.scn.community.shared.KeyLabelValueArray extends Array {
	org.scn.community.shared.KeyLabelValueArray (org.scn.community.shared.KeyLabelValue b);
}

/**
	Holder for Key, Label, Value + param1, param2, param3. You can access the content as in below example.
	<br>
	var content = COLLECTION_1.getAsKeyLabelValueProperty();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.KeyLabelValuePropertyArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.KeyLabelValueProperty<br>
		var elKey = element.key;<br>
		var elLabel = element.label;<br>
	 	var elValue = "( " + element.value + " )");<br>
	 	<br>
	 	var param1 = element.property1;<br>
	 	var param2 = element.property2;<br>
	 	var param3 = element.property3;<br>
	});
 */
class org.scn.community.shared.KeyLabelValueProperty {
	String key;
	String label;
	float value;
	String prop1;
	String prop2;
	String prop3;
}

/**
Array for org.scn.community.shared.KeyLabelValueProperty. You can use this array as in below example.
<br>
var content = COLLECTION_1.getAsKeyLabelValuePropertyArray();<br>
<br>
// a loop for all entries<br>
// content is of type org.scn.community.shared.KeyLabelValuePropertyArray<br>
content.forEach(function(element, index) {<br>

	// element is of type org.scn.community.shared.KeyLabelValueProperty<br>
	var elKey = element.key;<br>
	var elLabel = element.label;<br>
 	var elValue = "( " + element.value + " )");<br>
 	<br>
 	var param1 = element.prop1;<br>
 	var param2 = element.prop2;<br>
 	var param3 = element.prop3;<br>
 });
*/
class org.scn.community.shared.KeyLabelValuePropertyArray extends Array {
	org.scn.community.shared.KeyLabelValuePropertyArray (org.scn.community.shared.KeyLabelValueProperty b);
}

/**
	Holder for Name, Value. You can access the content as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.NameValueArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.NameValue<br>
		var elName = element.name;<br>
		var elValue = element.value;<br>
	});
 */
class org.scn.community.shared.NameValue {
  String name;
  String value;
}

/**
	Array for org.scn.community.shared.NameValue. You can use this array as in below example.
	<br>
	var content = COMPONENT.getSelectedElementsArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.NameValueArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.NameValueValue<br>
		var elName = element.name;<br>
		var elValue = element.value;<br>
	});
 */
class org.scn.community.shared.NameValueArray extends Array {
	org.scn.community.shared.NameValueArray (org.scn.community.shared.NameValue b);
}

/**
	Holder for value. You can use the content as in below example.
	<br>
	var content = COLLECTION_1.getAsValueTextArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.ValueTextArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.ValueText<br>
		var elValue = element.value;<br>
		var elText = element.text;<br>
	});
*/
class org.scn.community.shared.ValueText {
  String value;
  String text;
}

/**
	Array for org.scn.community.shared.ValueText. You can use this array as in below example.
	<br>
	var content = ARRAY_1.getAsValueTextArray();<br>
	<br>
	// a loop for all entries<br>
	// content is of type org.scn.community.shared.ValueTextArray<br>
	content.forEach(function(element, index) {<br>
	
		// element is of type org.scn.community.shared.ValueText<br>
		var elValue = element.value;<br>
		var elText = element.text;<br>
	});
*/
class org.scn.community.shared.ValueTextArray extends Array {
	org.scn.community.shared.ValueTextArray (org.scn.community.shared.ValueText b);
}
/** GENERATED BY SAPUI5 SIMPLE VALUES DEFINITIONS */

/**
 * Enumeration of possible BulletChart display modes.
 */
class org_scn_community_shared_BulletChartModeEnumfield extends Enumfield {
       
}

/**
 * Enumeration of possible BulletChart display modes. 
 */
class org_scn_community_shared_BulletChartMode extends Enum {

	/** Displays the Actual value. */
	org_scn_community_shared_BulletChartModeEnumfield Actual;

	/** Displays delta between the Actual and Threshold values. */
	org_scn_community_shared_BulletChartModeEnumfield Delta;


}


/**
 * Enumeration of possible theme specific background colors.
 */
class org_scn_community_shared_CommonBackgroundEnumfield extends Enumfield {
       
}

/**
 * Enumeration of possible theme specific background colors. 
 */
class org_scn_community_shared_CommonBackground extends Enum {

	/** The lightest background color. */
	org_scn_community_shared_CommonBackgroundEnumfield Lightest;

	/** Extra light background color. */
	org_scn_community_shared_CommonBackgroundEnumfield ExtraLight;

	/** Light background color. */
	org_scn_community_shared_CommonBackgroundEnumfield Light;

	/** Medium light background color. */
	org_scn_community_shared_CommonBackgroundEnumfield MediumLight;

	/** Medium background color. */
	org_scn_community_shared_CommonBackgroundEnumfield Medium;

	/** Dark background color. */
	org_scn_community_shared_CommonBackgroundEnumfield Dark;

	/** Extra dark background color. */
	org_scn_community_shared_CommonBackgroundEnumfield ExtraDark;

	/** The darkest background color. */
	org_scn_community_shared_CommonBackgroundEnumfield Darkest;


}


/**
 * Enumeration of possible PointTile size settings.
 */
class org_scn_community_shared_InfoTileSizeEnumfield extends Enumfield {
       
}

/**
 * Enumeration of possible PointTile size settings. 
 */
class org_scn_community_shared_InfoTileSize extends Enum {

	/** Extra small size. */
	org_scn_community_shared_InfoTileSizeEnumfield XS;

	/** Small size. */
	org_scn_community_shared_InfoTileSizeEnumfield S;

	/** Medium size. */
	org_scn_community_shared_InfoTileSizeEnumfield M;

	/** Large size. */
	org_scn_community_shared_InfoTileSizeEnumfield L;

	/** The size of the tile depends on the device it is running on. It is large on desktop, medium on tablet and small on phone. */
	org_scn_community_shared_InfoTileSizeEnumfield Auto;


}


/**
 * Enumeration of possible InfoTile value color settings.
 */
class org_scn_community_shared_InfoTileValueColorEnumfield extends Enumfield {
       
}

/**
 * Enumeration of possible InfoTile value color settings. 
 */
class org_scn_community_shared_InfoTileValueColor extends Enum {

	/** Neutral InfoTile value color. */
	org_scn_community_shared_InfoTileValueColorEnumfield Neutral;

	/** Good InfoTile value color. */
	org_scn_community_shared_InfoTileValueColorEnumfield Good;

	/** Critical InfoTile value color. */
	org_scn_community_shared_InfoTileValueColorEnumfield Critical;

	/** Error InfoTile value color. */
	org_scn_community_shared_InfoTileValueColorEnumfield Error;


}


/**
 * The list of possible MicroAreaChart views.
 */
class org_scn_community_shared_MicroAreaChartViewEnumfield extends Enumfield {
       
}

/**
 * The list of possible MicroAreaChart views. 
 */
class org_scn_community_shared_MicroAreaChartView extends Enum {

	/** The view with labels on the top and bottom. */
	org_scn_community_shared_MicroAreaChartViewEnumfield Normal;

	/** The view with labels on the left and right. */
	org_scn_community_shared_MicroAreaChartViewEnumfield Wide;


}
/** GENERATED BY SAPUI5 CONTROLS DEFINITIONS */

/**
 * Generated ZTL Class for BulletChart
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.BulletChart extends org.scn.community.shared.DataComponent {

	/** Adds a root element containing key [String], color [String], value [float].

 	<example>
	You want to add 2 root elements
	<code>
	BULLETCHART.addActual(key [String], color [String], value [float]);<br>
	BULLETCHART.addActual(key [String], color [String], value [float]);<br>
	<br>
	</code>
	</example>
	 */
	void setActual (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
			};

		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			this.actual = "[]";
		}

		var elementsJson = JSON.parse(this.actual);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.actual = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	BULLETCHART.removeActual(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearActual (
			
			) {*

		this.actual = "[]";
	*}

	/**
	 * Updates given Actual<br/>
	 */
	void updateActual (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			this.actual = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
		};

		var elementsJson = JSON.parse(this.actual);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.actual = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getActual (
			
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			this.actual = "[]";
		}

		var elementsJson = JSON.parse(this.actual);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Actuals As JSON String
	 */	
	String getActualsAsJSON() {*
		var jsonObject = JSON.parse(this.actual);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for Actual keys<br/>
	 */
	void setActualColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.actual);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.actual = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Actual Key<br/>
	 */
	void setActualColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.actual);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.actual = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for Actual Key<br/>
	 */
	boolean hasActualColor (
			/**/ String key
			) 
	{*
		if (this.actual === undefined || this.actual === "" || this.actual === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.actual);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/**
	 * Sets Actual Value Label Property
	 */	
	void setActualValueLabel( /**Actual Value Label*/ String actualValueLabel){*
		this.actualValueLabel = actualValueLabel;
	*}

	/**
	 * Gets Actual Value Label Property
	 */	
	String getActualValueLabel() {*
		return this.actualValueLabel;
	*}

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}

	/**
	 * Sets Delta Value Label Property
	 */	
	void setDeltaValueLabel( /**Delta Value Label*/ String deltaValueLabel){*
		this.deltaValueLabel = deltaValueLabel;
	*}

	/**
	 * Gets Delta Value Label Property
	 */	
	String getDeltaValueLabel() {*
		return this.deltaValueLabel;
	*}

	/**
	 * Sets Forecast Value Property
	 */	
	void setForecastValue( /**Forecast Value*/ float forecastValue){*
		this.forecastValue = forecastValue;
	*}

	/**
	 * Gets Forecast Value Property
	 */	
	float getForecastValue() {*
		return this.forecastValue;
	*}

	/**
	 * Sets Max Value Property
	 */	
	void setMaxValue( /**Max Value*/ float maxValue){*
		this.maxValue = maxValue;
	*}

	/**
	 * Gets Max Value Property
	 */	
	float getMaxValue() {*
		return this.maxValue;
	*}

	/**
	 * Sets Min Value Property
	 */	
	void setMinValue( /**Min Value*/ float minValue){*
		this.minValue = minValue;
	*}

	/**
	 * Gets Min Value Property
	 */	
	float getMinValue() {*
		return this.minValue;
	*}

	/**
	 * Sets Mode Property by String
	 */	
	void setModeByString( /**Mode*/ String mode){*
		this.mode = mode;
	*}

	/**
	 * Gets Mode Property as String
	 */	
	String getModeAsString() {*
		return this.mode;
	*}
	
	/**
	 * Sets Mode Property by Choice Option
	 */	
	void setMode( /**Mode*/ org_scn_community_shared_BulletChartModeEnumfield mode){*
		this.mode = mode;
	*}
	
	/**
	 * Gets Mode Property as Choice Option
	 */	
	org_scn_community_shared_BulletChartModeEnumfield getMode() {*
		return this.mode;
	*}

	/**
	 * Sets Scale Property
	 */	
	void setScale( /**Scale*/ String scale){*
		this.scale = scale;
	*}

	/**
	 * Gets Scale Property
	 */	
	String getScale() {*
		return this.scale;
	*}

	/**
	 * Sets Scale Colour Property by String
	 */	
	void setScaleColorByString( /**Scale Colour*/ String scaleColor){*
		this.scaleColor = scaleColor;
	*}

	/**
	 * Gets Scale Colour Property as String
	 */	
	String getScaleColorAsString() {*
		return this.scaleColor;
	*}
	
	/**
	 * Sets Scale Colour Property by Choice Option
	 */	
	void setScaleColor( /**Scale Colour*/ org_scn_community_shared_CommonBackgroundEnumfield scaleColor){*
		this.scaleColor = scaleColor;
	*}
	
	/**
	 * Gets Scale Colour Property as Choice Option
	 */	
	org_scn_community_shared_CommonBackgroundEnumfield getScaleColor() {*
		return this.scaleColor;
	*}

	/**
	 * Sets Show Actual Value Property
	 */	
	void setShowActualValue( /**Show Actual Value*/ boolean showActualValue){*
		this.showActualValue = showActualValue;
	*}

	/**
	 * Gets Show Actual Value Property
	 */	
	boolean isShowActualValue() {*
		return this.showActualValue;
	*}

	/**
	 * Sets Show Delta Value Property
	 */	
	void setShowDeltaValue( /**Show Delta Value*/ boolean showDeltaValue){*
		this.showDeltaValue = showDeltaValue;
	*}

	/**
	 * Gets Show Delta Value Property
	 */	
	boolean isShowDeltaValue() {*
		return this.showDeltaValue;
	*}

	/**
	 * Sets Show Target Value Property
	 */	
	void setShowTargetValue( /**Show Target Value*/ boolean showTargetValue){*
		this.showTargetValue = showTargetValue;
	*}

	/**
	 * Gets Show Target Value Property
	 */	
	boolean isShowTargetValue() {*
		return this.showTargetValue;
	*}

	/**
	 * Sets Show Value Marker Property
	 */	
	void setShowValueMarker( /**Show Value Marker*/ boolean showValueMarker){*
		this.showValueMarker = showValueMarker;
	*}

	/**
	 * Gets Show Value Marker Property
	 */	
	boolean isShowValueMarker() {*
		return this.showValueMarker;
	*}

	/**
	 * Sets Size Property by String
	 */	
	void setSizeByString( /**Size*/ String size){*
		this.size = size;
	*}

	/**
	 * Gets Size Property as String
	 */	
	String getSizeAsString() {*
		return this.size;
	*}
	
	/**
	 * Sets Size Property by Choice Option
	 */	
	void setSize( /**Size*/ org_scn_community_shared_InfoTileSizeEnumfield size){*
		this.size = size;
	*}
	
	/**
	 * Gets Size Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileSizeEnumfield getSize() {*
		return this.size;
	*}

	/**
	 * Sets Target Value Property
	 */	
	void setTargetValue( /**Target Value*/ float targetValue){*
		this.targetValue = targetValue;
	*}

	/**
	 * Gets Target Value Property
	 */	
	float getTargetValue() {*
		return this.targetValue;
	*}

	/**
	 * Sets Target Value Label Property
	 */	
	void setTargetValueLabel( /**Target Value Label*/ String targetValueLabel){*
		this.targetValueLabel = targetValueLabel;
	*}

	/**
	 * Gets Target Value Label Property
	 */	
	String getTargetValueLabel() {*
		return this.targetValueLabel;
	*}

	/** Adds a root element containing key [String], color [String], value [float].

 	<example>
	You want to add 2 root elements
	<code>
	BULLETCHART.addThreshold(key [String], color [String], value [float]);<br>
	BULLETCHART.addThreshold(key [String], color [String], value [float]);<br>
	<br>
	</code>
	</example>
	 */
	void addThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
			};

		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var elementsJson = JSON.parse(this.thresholds);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	BULLETCHART.removeThreshold(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removeThreshold (
			String key
			) {*

		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var elementsJson = JSON.parse(this.thresholds);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	BULLETCHART.insertThreshold(index [int], key [String], color [String], value [float]);<br>
	<br>
	</code>
	</example>
	 */
	void insertThreshold (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) {*

		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}
		
		var elementsJson = JSON.parse(this.thresholds);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.thresholds = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Threshold<br/>
	 */
	void updateThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Value*/float value
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			value:value
		};

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getThresholdAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			this.thresholds = "[]";
		}

		var elementsJson = JSON.parse(this.thresholds);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Thresholds As JSON String
	 */	
	String getThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.thresholds);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for Threshold keys<br/>
	 */
	void setThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.thresholds = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Threshold Key<br/>
	 */
	void setThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.thresholds);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.thresholds = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for Threshold Key<br/>
	 */
	boolean hasThresholdColor (
			/**/ String key
			) 
	{*
		if (this.thresholds === undefined || this.thresholds === "" || this.thresholds === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.thresholds);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}




	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for BulletChartData
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.BulletChartData extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}

	/**
	 * Sets Value Property
	 */	
	void setValue( /**Value*/ float value){*
		this.value = value;
	*}

	/**
	 * Gets Value Property
	 */	
	float getValue() {*
		return this.value;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChart
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChart extends org.scn.community.shared.DataComponent {

	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			this.chart = "[]";
		}
		
		var elementsJson = JSON.parse(this.chart);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.chart = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setChart(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setChart (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			this.chart = "[]";
		}
		
		var elementsJson = JSON.parse(this.chart);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.chart = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			this.chart = "[]";
		}
		
		var elementsJson = JSON.parse(this.chart);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.chart = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearChart();<br>
	<br>
	</code>
	</example>
	 */
	void clearChart (
			
			) {*		
		
		this.chart = "[]";
	*}

	/**
	 * Gets Charts As JSON String
	 */	
	String getChartsAsJSON() {*
		var jsonObject = JSON.parse(this.chart);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for Chart keys<br/>
	 */
	void setChartColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.chart);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.chart = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Chart Key<br/>
	 */
	void setChartColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.chart);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.chart = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for Chart Key<br/>
	 */
	boolean hasChartColor (
			/**/ String key
			) 
	{*
		if (this.chart === undefined || this.chart === "" || this.chart === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.chart);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/**
	 * Sets Content Height Property
	 */	
	void setContentHeight( /**Content Height*/ int contentHeight){*
		this.contentHeight = contentHeight;
	*}

	/**
	 * Gets Content Height Property
	 */	
	int getContentHeight() {*
		return this.contentHeight;
	*}

	/**
	 * Sets Content Width Property
	 */	
	void setContentWidth( /**Content Width*/ int contentWidth){*
		this.contentWidth = contentWidth;
	*}

	/**
	 * Gets Content Width Property
	 */	
	int getContentWidth() {*
		return this.contentWidth;
	*}

	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addFirstXLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addFirstXLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setFirstXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			this.firstXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeFirstXLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearFirstXLabel (
			
			) {*

		this.firstXLabel = "[]";
	*}

	/**
	 * Updates given FirstXLabel<br/>
	 */
	void updateFirstXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			this.firstXLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getFirstXLabel (
			
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			this.firstXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets FirstXLabels As JSON String
	 */	
	String getFirstXLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.firstXLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for FirstXLabel keys<br/>
	 */
	void setFirstXLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.firstXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for FirstXLabel Key<br/>
	 */
	void setFirstXLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for FirstXLabel Key<br/>
	 */
	boolean hasFirstXLabelColor (
			/**/ String key
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for FirstXLabel keys<br/>
	 */
	void setFirstXLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.firstXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for FirstXLabel Key<br/>
	 */
	void setFirstXLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.firstXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for FirstXLabel Key<br/>
	 */
	boolean hasFirstXLabelLabel (
			/**/ String key
			) 
	{*
		if (this.firstXLabel === undefined || this.firstXLabel === "" || this.firstXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstXLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addFirstYLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addFirstYLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setFirstYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			this.firstYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeFirstYLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearFirstYLabel (
			
			) {*

		this.firstYLabel = "[]";
	*}

	/**
	 * Updates given FirstYLabel<br/>
	 */
	void updateFirstYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			this.firstYLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getFirstYLabel (
			
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			this.firstYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets FirstYLabels As JSON String
	 */	
	String getFirstYLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.firstYLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for FirstYLabel keys<br/>
	 */
	void setFirstYLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.firstYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for FirstYLabel Key<br/>
	 */
	void setFirstYLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for FirstYLabel Key<br/>
	 */
	boolean hasFirstYLabelColor (
			/**/ String key
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for FirstYLabel keys<br/>
	 */
	void setFirstYLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.firstYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for FirstYLabel Key<br/>
	 */
	void setFirstYLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.firstYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for FirstYLabel Key<br/>
	 */
	boolean hasFirstYLabelLabel (
			/**/ String key
			) 
	{*
		if (this.firstYLabel === undefined || this.firstYLabel === "" || this.firstYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.firstYLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			this.innerMaxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMaxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setInnerMaxThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setInnerMaxThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			this.innerMaxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			this.innerMaxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMaxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearInnerMaxThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearInnerMaxThreshold (
			
			) {*		
		
		this.innerMaxThreshold = "[]";
	*}

	/**
	 * Gets InnerMaxThresholds As JSON String
	 */	
	String getInnerMaxThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.innerMaxThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for InnerMaxThreshold keys<br/>
	 */
	void setInnerMaxThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for InnerMaxThreshold Key<br/>
	 */
	void setInnerMaxThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.innerMaxThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for InnerMaxThreshold Key<br/>
	 */
	boolean hasInnerMaxThresholdColor (
			/**/ String key
			) 
	{*
		if (this.innerMaxThreshold === undefined || this.innerMaxThreshold === "" || this.innerMaxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMaxThreshold);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			this.innerMinThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMinThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setInnerMinThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setInnerMinThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			this.innerMinThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMinThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			this.innerMinThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.innerMinThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearInnerMinThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearInnerMinThreshold (
			
			) {*		
		
		this.innerMinThreshold = "[]";
	*}

	/**
	 * Gets InnerMinThresholds As JSON String
	 */	
	String getInnerMinThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.innerMinThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for InnerMinThreshold keys<br/>
	 */
	void setInnerMinThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.innerMinThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for InnerMinThreshold Key<br/>
	 */
	void setInnerMinThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMinThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.innerMinThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for InnerMinThreshold Key<br/>
	 */
	boolean hasInnerMinThresholdColor (
			/**/ String key
			) 
	{*
		if (this.innerMinThreshold === undefined || this.innerMinThreshold === "" || this.innerMinThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.innerMinThreshold);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addLastXLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addLastXLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setLastXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			this.lastXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeLastXLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearLastXLabel (
			
			) {*

		this.lastXLabel = "[]";
	*}

	/**
	 * Updates given LastXLabel<br/>
	 */
	void updateLastXLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			this.lastXLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getLastXLabel (
			
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			this.lastXLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets LastXLabels As JSON String
	 */	
	String getLastXLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.lastXLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for LastXLabel keys<br/>
	 */
	void setLastXLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.lastXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for LastXLabel Key<br/>
	 */
	void setLastXLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for LastXLabel Key<br/>
	 */
	boolean hasLastXLabelColor (
			/**/ String key
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for LastXLabel keys<br/>
	 */
	void setLastXLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.lastXLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for LastXLabel Key<br/>
	 */
	void setLastXLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.lastXLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for LastXLabel Key<br/>
	 */
	boolean hasLastXLabelLabel (
			/**/ String key
			) 
	{*
		if (this.lastXLabel === undefined || this.lastXLabel === "" || this.lastXLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastXLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addLastYLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addLastYLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setLastYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			this.lastYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeLastYLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearLastYLabel (
			
			) {*

		this.lastYLabel = "[]";
	*}

	/**
	 * Updates given LastYLabel<br/>
	 */
	void updateLastYLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			this.lastYLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getLastYLabel (
			
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			this.lastYLabel = "[]";
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets LastYLabels As JSON String
	 */	
	String getLastYLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.lastYLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for LastYLabel keys<br/>
	 */
	void setLastYLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.lastYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for LastYLabel Key<br/>
	 */
	void setLastYLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for LastYLabel Key<br/>
	 */
	boolean hasLastYLabelColor (
			/**/ String key
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for LastYLabel keys<br/>
	 */
	void setLastYLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.lastYLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for LastYLabel Key<br/>
	 */
	void setLastYLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.lastYLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for LastYLabel Key<br/>
	 */
	boolean hasLastYLabelLabel (
			/**/ String key
			) 
	{*
		if (this.lastYLabel === undefined || this.lastYLabel === "" || this.lastYLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.lastYLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addMaxLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addMaxLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setMaxLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			this.maxLabel = "[]";
		}

		var elementsJson = JSON.parse(this.maxLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeMaxLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearMaxLabel (
			
			) {*

		this.maxLabel = "[]";
	*}

	/**
	 * Updates given MaxLabel<br/>
	 */
	void updateMaxLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			this.maxLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getMaxLabel (
			
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			this.maxLabel = "[]";
		}

		var elementsJson = JSON.parse(this.maxLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets MaxLabels As JSON String
	 */	
	String getMaxLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.maxLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for MaxLabel keys<br/>
	 */
	void setMaxLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.maxLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MaxLabel Key<br/>
	 */
	void setMaxLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for MaxLabel Key<br/>
	 */
	boolean hasMaxLabelColor (
			/**/ String key
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for MaxLabel keys<br/>
	 */
	void setMaxLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.maxLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for MaxLabel Key<br/>
	 */
	void setMaxLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.maxLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for MaxLabel Key<br/>
	 */
	boolean hasMaxLabelLabel (
			/**/ String key
			) 
	{*
		if (this.maxLabel === undefined || this.maxLabel === "" || this.maxLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			this.maxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.maxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.maxThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setMaxThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setMaxThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			this.maxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.maxThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			this.maxThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.maxThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearMaxThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearMaxThreshold (
			
			) {*		
		
		this.maxThreshold = "[]";
	*}

	/**
	 * Gets MaxThresholds As JSON String
	 */	
	String getMaxThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.maxThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for MaxThreshold keys<br/>
	 */
	void setMaxThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.maxThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.maxThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MaxThreshold Key<br/>
	 */
	void setMaxThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.maxThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for MaxThreshold Key<br/>
	 */
	boolean hasMaxThresholdColor (
			/**/ String key
			) 
	{*
		if (this.maxThreshold === undefined || this.maxThreshold === "" || this.maxThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.maxThreshold);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/**
	 * Sets Max X Value Property
	 */	
	void setMaxXValue( /**Max X Value*/ float maxXValue){*
		this.maxXValue = maxXValue;
	*}

	/**
	 * Gets Max X Value Property
	 */	
	float getMaxXValue() {*
		return this.maxXValue;
	*}

	/**
	 * Sets Max Y Value Property
	 */	
	void setMaxYValue( /**Max Y Value*/ float maxYValue){*
		this.maxYValue = maxYValue;
	*}

	/**
	 * Gets Max Y Value Property
	 */	
	float getMaxYValue() {*
		return this.maxYValue;
	*}

	/** Adds a root element containing key [String], color [String], label [String].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHART.addMinLabel(key [String], color [String], label [String]);<br>
	MICROAREACHART.addMinLabel(key [String], color [String], label [String]);<br>
	<br>
	</code>
	</example>
	 */
	void setMinLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
			};

		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			this.minLabel = "[]";
		}

		var elementsJson = JSON.parse(this.minLabel);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.removeMinLabel(String key);<br>
	<br>
	</code>
	</example>
	 */
	void clearMinLabel (
			
			) {*

		this.minLabel = "[]";
	*}

	/**
	 * Updates given MinLabel<br/>
	 */
	void updateMinLabel (
			/**Unique Property Key*/String key, 
			/**Colour*/String color, 
			/**Label*/String label
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			this.minLabel = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			color:color, 
			label:label
		};

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getMinLabel (
			
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			this.minLabel = "[]";
		}

		var elementsJson = JSON.parse(this.minLabel);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == 0) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets MinLabels As JSON String
	 */	
	String getMinLabelsAsJSON() {*
		var jsonObject = JSON.parse(this.minLabel);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for MinLabel keys<br/>
	 */
	void setMinLabelColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.minLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MinLabel Key<br/>
	 */
	void setMinLabelColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for MinLabel Key<br/>
	 */
	boolean hasMinLabelColor (
			/**/ String key
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}
	/**
	 * Sets the Label for MinLabel keys<br/>
	 */
	void setMinLabelLabels (
			/**/ String keys,
			/**/ String separator,
	        /* Label */ String label
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].label = label;
					break;
				}
			}
		}
		
		this.minLabel = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Label for MinLabel Key<br/>
	 */
	void setMinLabelLabel (
			/**/ String key,
			/**/ String label
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].label = label;
				break;
			}
		}

		this.minLabel = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Label for MinLabel Key<br/>
	 */
	boolean hasMinLabelLabel (
			/**/ String key
			) 
	{*
		if (this.minLabel === undefined || this.minLabel === "" || this.minLabel === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minLabel);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}



	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			this.minThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.minThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.minThreshold = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setMinThreshold(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setMinThreshold (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			this.minThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.minThreshold);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			this.minThreshold = "[]";
		}
		
		var elementsJson = JSON.parse(this.minThreshold);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearMinThreshold();<br>
	<br>
	</code>
	</example>
	 */
	void clearMinThreshold (
			
			) {*		
		
		this.minThreshold = "[]";
	*}

	/**
	 * Gets MinThresholds As JSON String
	 */	
	String getMinThresholdsAsJSON() {*
		var jsonObject = JSON.parse(this.minThreshold);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for MinThreshold keys<br/>
	 */
	void setMinThresholdColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.minThreshold);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.minThreshold = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for MinThreshold Key<br/>
	 */
	void setMinThresholdColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minThreshold);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.minThreshold = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for MinThreshold Key<br/>
	 */
	boolean hasMinThresholdColor (
			/**/ String key
			) 
	{*
		if (this.minThreshold === undefined || this.minThreshold === "" || this.minThreshold === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.minThreshold);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/**
	 * Sets Min X Value Property
	 */	
	void setMinXValue( /**Min X Value*/ float minXValue){*
		this.minXValue = minXValue;
	*}

	/**
	 * Gets Min X Value Property
	 */	
	float getMinXValue() {*
		return this.minXValue;
	*}

	/**
	 * Sets Min Y Value Property
	 */	
	void setMinYValue( /**Min Y Value*/ float minYValue){*
		this.minYValue = minYValue;
	*}

	/**
	 * Gets Min Y Value Property
	 */	
	float getMinYValue() {*
		return this.minYValue;
	*}

	/** Adds an element containing parentKey [String], key [String], x [float], y [float] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to add 2 elements
	<code>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);<br>
	MICROAREACHART.addPoints(parentKey [String], key [String], x [float], y [float]);
	</code>
	</example>
	 */
	void addPoints (
			/**Parent Key*/String parentKey, 
			/**Unique Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*		
		
		var leaf = (parentKey != "ROOT");
		
		
		var itemDef = {
			leaf:leaf,
			parentKey:parentKey, 
			key:key, 
			x:x, 
			y:y 
			};
	
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			this.target = "[]";
		}
		
		var elementsJson = JSON.parse(this.target);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.target = JSON.stringify(elementsJson);
	*}
	
	/** Sets an element containing key [String], color [String] properties.
	 * You need to specify a unique and existing parent element.

 	<example>
	You want to set the element
	<code>
	MICROAREACHART.setTarget(key [String], color [String]);<br>
	</code>
	</example>
	 */
	void setTarget (
			/**Unique Property Key*/String key, 
			/**Colour*/String color
			) {*		
		
		
		var itemDef = {
			leaf:false,
			parentKey:"ROOT",
			key:key, 
			color:color 
			};
	
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			this.target = "[]";
		}
		
		var elementsJson = JSON.parse(this.target);

		// clear always
		if(elementsJson.length == 1) {
			elementsJson = [];
		}

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}
		
		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}
	
		this.target = JSON.stringify(elementsJson);
	*}

	/** removes an element by String key properties.
	 * You need to specify a unique and existing key.

 	<example>
	You want to remove element
	<code>
	MICROAREACHART.removePoints(String key);<br>
	</code>
	</example>
	 */
	void removePoints (
			String key
			) {*		
		
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			this.target = "[]";
		}
		
		var elementsJson = JSON.parse(this.target);
		
		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.target = JSON.stringify(elementsJson);
	*}

	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHART.clearTarget();<br>
	<br>
	</code>
	</example>
	 */
	void clearTarget (
			
			) {*		
		
		this.target = "[]";
	*}

	/**
	 * Gets Targets As JSON String
	 */	
	String getTargetsAsJSON() {*
		var jsonObject = JSON.parse(this.target);
		return JSON.stringify(jsonObject, null, 4);
	*}
	
	/**
	 * Sets the Color for Target keys<br/>
	 */
	void setTargetColors (
			/**/ String keys,
			/**/ String separator,
	        /* Color */ String color
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}
	
		var changeKeys = keys.split(separator);	

		var elementsJson = JSON.parse(this.target);

		// loop and find and change
		for (var i = 0; i < elementsJson.length ; i++){
			for (var j = 0; j < changeKeys.length ; j++){
				if (elementsJson[i].key == changeKeys[j]) {
					elementsJson[i].color = color;
					break;
				}
			}
		}
		
		this.target = JSON.stringify(elementsJson);
	*}

	/**
	 * Sets the Color for Target Key<br/>
	 */
	void setTargetColor (
			/**/ String key,
			/**/ String color
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.target);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson[i].color = color;
				break;
			}
		}

		this.target = JSON.stringify(elementsJson);
	*}
	
	/**
	 * Checks Existence of Color for Target Key<br/>
	 */
	boolean hasTargetColor (
			/**/ String key
			) 
	{*
		if (this.target === undefined || this.target === "" || this.target === "<delete>"){
			return;
		}

		var elementsJson = JSON.parse(this.target);

		var exists = false;
		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				exists = true;
				break;
			}
		}
		
		return exists;
	*}


	/**
	 * Sets View Property by String
	 */	
	void setViewByString( /**View*/ String view){*
		this.view = view;
	*}

	/**
	 * Gets View Property as String
	 */	
	String getViewAsString() {*
		return this.view;
	*}
	
	/**
	 * Sets View Property by Choice Option
	 */	
	void setView( /**View*/ org_scn_community_shared_MicroAreaChartViewEnumfield view){*
		this.view = view;
	*}
	
	/**
	 * Gets View Property as Choice Option
	 */	
	org_scn_community_shared_MicroAreaChartViewEnumfield getView() {*
		return this.view;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChartItem
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChartItem extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}

	/** Adds a root element containing key [String], x [float], y [float].

 	<example>
	You want to add 2 root elements
	<code>
	MICROAREACHARTITEM.addPoint(key [String], x [float], y [float]);<br>
	MICROAREACHARTITEM.addPoint(key [String], x [float], y [float]);<br>
	<br>
	</code>
	</example>
	 */
	void addPoint (
			/**Unique Property Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*

		
		var itemDef = {
			leaf:true,
			key:key, 
			x:x, 
			y:y
			};

		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var elementsJson = JSON.parse(this.points);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				alreadyFound = true;
				break;
			}
		}

		if(!alreadyFound) {
			elementsJson.push(itemDef);
		}

		this.points = JSON.stringify(elementsJson);
	*}
	
	/** Removes a root element by key.

 	<example>
	You want to remove root element
	<code>
	MICROAREACHARTITEM.removePoint(String key);<br>
	<br>
	</code>
	</example>
	 */
	void removePoint (
			String key
			) {*

		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var elementsJson = JSON.parse(this.points);

		var alreadyFound = false;
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == key) {
				elementsJson.splice(i,1);
				break;
			}
		}

		// remove all items with this parent
		for (var i = elementsJson.length - 1; i >= 0; i--){
			if (elementsJson[i].parentKey == key) {
				elementsJson.splice(i,1);
			}
		}

		this.points = JSON.stringify(elementsJson);
	*}

	/** Insert a root element by index.

 	<example>
	You want to insert a root element
	<code>
	MICROAREACHARTITEM.insertPoint(index [int], key [String], x [float], y [float]);<br>
	<br>
	</code>
	</example>
	 */
	void insertPoint (
			/**Index to Insert (0-based)*/int insertionIndex0based,
			/**Unique Property Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) {*

		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}
		
		var elementsJson = JSON.parse(this.points);
		var newElementsJson = [];

		var itemDef = {
			leaf:true,
			key:key, 
			x:x, 
			y:y
		};

		for (var i = 0; i < elementsJson.length ; i++){
			if (i == insertionIndex0based) {
				newElementsJson.push(itemDef);
			}

			newElementsJson.push(elementsJson[i]);
		}

		this.points = JSON.stringify(newElementsJson);
	*}

	/**
	 * Updates given Point<br/>
	 */
	void updatePoint (
			/**Unique Property Key*/String key, 
			/**X*/float x, 
			/**Y*/float y
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var itemDef = {
			leaf:true,
			key:key, 
			x:x, 
			y:y
		};

		var elementsJson = JSON.parse(this.points);

		// loop and find and update
		for (var i = 0; i < elementsJson.length ; i++){
			if (elementsJson[i].key == elementKey) {
				elementsJson[i] = itemDef;
				break;
			}
		}

		this.points = JSON.stringify(elementsJson);
	*}

	/**
	 * Returns Key at given Index<br/>
	 */
	String getPointAtIndex (
			/**Index to pick the key*/ int index0based
			) 
	{*
		if (this.points === undefined || this.points === "" || this.points === "<delete>"){
			this.points = "[]";
		}

		var elementsJson = JSON.parse(this.points);

		for (var i = 0; i < elementsJson.length ; i++){
			if (index0based == i) {
				return elementsJson[i].key;
			}
		}

		return "";
	*}

	/**
	 * Gets Points As JSON String
	 */	
	String getPointsAsJSON() {*
		var jsonObject = JSON.parse(this.points);
		return JSON.stringify(jsonObject, null, 4);
	*}
	




	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChartLabel
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChartLabel extends org.scn.community.shared.DataComponent {

	/**
	 * Sets Colour Property by String
	 */	
	void setColorByString( /**Colour*/ String color){*
		this.color = color;
	*}

	/**
	 * Gets Colour Property as String
	 */	
	String getColorAsString() {*
		return this.color;
	*}
	
	/**
	 * Sets Colour Property by Choice Option
	 */	
	void setColor( /**Colour*/ org_scn_community_shared_InfoTileValueColorEnumfield color){*
		this.color = color;
	*}
	
	/**
	 * Gets Colour Property as Choice Option
	 */	
	org_scn_community_shared_InfoTileValueColorEnumfield getColor() {*
		return this.color;
	*}

	/**
	 * Sets Label Property
	 */	
	void setLabel( /**Label*/ String label){*
		this.label = label;
	*}

	/**
	 * Gets Label Property
	 */	
	String getLabel() {*
		return this.label;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}


/**
 * Generated ZTL Class for MicroAreaChartPoint
 * 
 * DO NOT EDIT, ROOT SOURCE is based on SAP UI5 specification
 */
class org.scn.community.shared.ui5.MicroAreaChartPoint extends org.scn.community.shared.DataComponent {

	/**
	 * Sets X Property
	 */	
	void setX( /**X*/ float x){*
		this.x = x;
	*}

	/**
	 * Gets X Property
	 */	
	float getX() {*
		return this.x;
	*}

	/**
	 * Sets Y Property
	 */	
	void setY( /**Y*/ float y){*
		this.y = y;
	*}

	/**
	 * Gets Y Property
	 */	
	float getY() {*
		return this.y;
	*}


	/* START HERE PLACE FOR CUSTOM ZTL FUNCTIONS */

}
/**
 * Class for reusable ZTL component methods
 */
class org.scn.community.shared.Component extends Component {
	
	@Visibility(private)
	void internalWriteLog(String log) {*
		// only for debugging
		var active = false;
	
		if(active) {
			APPLICATION.log(log);
		}
	*}

	/**
	 * DO NOT USE, ONLY FOR DEBUG ACTIVATION
	 */
	@Visibility(private)
	boolean isDebug(optional String componentName) {*
		// quick check here
		if(componentName == undefined) {
			if(this._dbgDEBUG == "+") { return true; }
			if(this._dbgDEBUG == "-") { return false; }
			componentName = "DEBUG";
		} else {
			if(this["_dbg" + componentName] == "+") { return true; }
			if(this["_dbg" + componentName] == "-") { return false; }
		}
	
		internal_assureGlobalAccess ();
		
		var something = this.getGlobal()[componentName];
		if(something != undefined) {
			this["_dbg" + componentName] == "+";
			return true;
		} else {
			this["_dbg" + componentName] == "-";
			return false;
		}
	*}
	
	/**
	 * Internal function to read return global scope
	 * http://stackoverflow.com/questions/1162998/how-can-i-add-an-object-property-to-the-global-object-in-rhino-javascript
	 */
	@Visibility(private)
	void internal_assureGlobalAccess () {*
		if(this.getGlobal == undefined) {
			this.getGlobal = function () {
				return (function() {
					return this;
				}).call(null);
			}
		}
	*}
	
	/**
	 * Converts Choice values to Strings
	 */
	@Visibility(private)
	String convertChoiceToString (String choice) {*
		return choice;
	*}

	/**
	 * Converts String values to Choices
	 */
	@Visibility(private)
	String convertToStringChoice (String value) {*
		value = value.toUpper();
		value = value.replace(" ", "_");
		return value;
	*}
}

/**
 * Class for reusable ZTL data bound component methods
 */
class org.scn.community.shared.DataComponent extends org.scn.community.shared.Component {

	@Visibility(private)
	String superReadMembers(
			/**technical name of the dimension*/String dimensionName,
			/**max members to load (optional, default 1000)*/optional int maxMembers
			) {*
		var ds = this.getDataSource();
		
		var membersArray = [];
	
		if(maxMembers == undefined) {
			maxMembers = 1000;
		}
		
		var members = ds.getMembers(dimensionName, maxMembers);

		this.internalWriteLog("Load Members [length]: " + members.length);
		
		members.forEach(function(member, index) {
			var memberEntry = {};
			membersArray.push(memberEntry);
			
			memberEntry.key = member.internalKey;
			// member.internalNoncompoundedKey;
			memberEntry.keyExt = member.externalKey;
			// member.externalNoncompoundedKey;
			memberEntry.text = member.text;
		});
		
		var membersMetaData = {};
		membersMetaData.dimensionName = dimensionName;
		membersMetaData.members = membersArray;
		
		var result = JSON.stringify(membersMetaData);
		return result;
	
	*}
	
	@Visibility(private)
	String superReadMetaData() {*
		// APPLICATION.createInfoMessage("_readMetaData");
		
		var ds = this.getDataSource();
	  
		var dimensionsArray = [];
	
		var dims = ds.getDimensions();
		dims.forEach(function(element, index) {
			var dimEntry = {};
			dimensionsArray.push(dimEntry);
			dimEntry.name = element.name;
			dimEntry.text = element.text;
			
			if (element.isMeasuresDimension) {
				var measuresArray = [];
				var measures = ds.getMembers(element.name, 100);
				measures.forEach(function(measure) {
					var measureEntry = {};
					measuresArray.push(measureEntry);

					measureEntry.name = measure.internalKey;
					measureEntry.text = measure.text;
				});

				dimEntry.measures = measuresArray;
			} else {
				dimEntry.memberDisplay = ds.getMemberDisplay(element.name);
				dimEntry.showTotals = ds.getTotalsDisplay(element.name);
				dimEntry.hierarchies =  ds.getHierarchies(element.name);
				dimEntry.assignedHierarchy = ds.getAssignedHierarchy(element.name);
			}
		});

		var conditionalFormatsJson = [];
		var conditionalFormat = ds.getConditionalFormats();	// Issue Fix for Github Issue 22 reported by sschau
		conditionalFormat.forEach(function(element, index) {
		  var conditionalFormatJson = {};
		  conditionalFormatJson.push(conditionalFormatJson);
		  
		  conditionalFormatJson.id = element;
		  conditionalFormatJson.name = ds.getConditionalFormatName(element);
		  conditionalFormatJson.active = ds.isConditionalFormatActive(element);
		});
		
		var measureFiltersJson = [];
		var measureFilters = ds.getMeasureFilters();
		measureFilters.forEach(function(element, index) {
		  var conditionJson = {};
		  measureFiltersJson.push(conditionJson);
		  
		  measureFilterJson.id = element;
		  measureFilterJson.name = ds.getMeasureFilterName(element);
		  measureFilterJson.active = ds.isMeasureFilterActive(element);
		});
		
		var dataSourceMetaData = {};
		dataSourceMetaData.dimensions = dimensionsArray;
		dataSourceMetaData.conditionalFormats = conditionalFormatsJson;
		dataSourceMetaData.measureFilters = measureFiltersJson;
		
		var result = JSON.stringify(dataSourceMetaData);
		return result;
	*}
}

class org.scn.community.shared.BufferDataSource extends SdkDataBuffer {
	
}